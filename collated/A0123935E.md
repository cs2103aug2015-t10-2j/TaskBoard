# A0123935E
###### src\com\taskboard\main\command\AddCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.DateTimeProcessor;
import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Add command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class AddCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_AFTER_ADD = "Entry successfully added:";
	private static final String MESSAGE_ERROR_FOR_ADD = "The entry could not be added to the file.";

	public AddCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		// _parameters should minimally have the name of entry for Add command to be valid
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of AddCommand");
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		Response responseForAdd = new Response();
		if (isAddFloatingTask()) {
			_logger.log(Level.INFO, "Start process of adding floating task");
			responseForAdd = addFloatingTask();
		} else if (isAddDeadlineTask()) {
			_logger.log(Level.INFO, "Start process of adding deadline task");
			responseForAdd = addDeadlineTask();
		} else if (isAddEvent()) {
			_logger.log(Level.INFO, "Start process of adding event");
			responseForAdd = addEvent();
		}
		
		// facilitates the Undo command 
		if (responseForAdd.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForAdd;
	}
	
	private boolean isAddFloatingTask() {
		if(!isAddDeadlineTask() && !isAddEvent()) {
			return true;
		}
		
		return false;
	}
	
	private boolean isAddDeadlineTask() {
		Parameter dateParameter = getDateParameter();
		Parameter timeParameter = getTimeParameter();
		if (dateParameter != null || timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private boolean isAddEvent() {
		Parameter startDateParameter = getStartDateParameter();
		Parameter startTimeParameter = getStartTimeParameter();
		if (startDateParameter != null || startTimeParameter != null) {
			return true;
		}
		
		return false;
	}
		
	private Response addFloatingTask() {
		String taskName = getDetailFromParameter(getNameParameter());
		assert !taskName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of floating task: " + taskName);
		
		_logger.log(Level.INFO, "Start processing floating task for storage");
		Response responseForAddFloating = processFloatingTaskForStorage();
		
		return responseForAddFloating;
	}
	
	private Response processFloatingTaskForStorage() {
		Entry floatingTask = createFloatingTask();
		_logger.log(Level.INFO, "Successfully created floating task");
		Response responseForAddFloating = updateNewEntryToStorage(floatingTask);
			
		return responseForAddFloating;
	}
		
	private Entry createFloatingTask() {
		Entry floatingTask = new Entry();
		addParameterToEntry(floatingTask, new Parameter(ParameterType.INDEX, ""));
		addParameterToEntry(floatingTask, getNameParameter());
		addParameterToEntry(floatingTask, getPriorityParameter());
		addParameterToEntry(floatingTask, getCategoryParameter());
			
		return floatingTask;
	}
	
	private void addParameterToEntry(Entry entry, Parameter parameter) {
		if (parameter != null) {
			entry.addToParameters(parameter);
		}
	}
		
	private Response updateNewEntryToStorage(Entry entry) {
		Response responseForAdd = new Response();
		try {
			_tempStorageManipulator.addToTempStorage(entry);
			setSuccessResponseForAdd(responseForAdd, entry);
			_logger.log(Level.INFO, "Generated success response for adding entry");
		} catch (IOException ex) {
			setFailureResponseForAdd(responseForAdd);
			_logger.log(Level.INFO, "Generated failure response for adding entry");
		}
		
		return responseForAdd;
	}
	
	private void setSuccessResponseForAdd(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackforSuccessfulAdd(entry);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackforSuccessfulAdd(Entry entry) {
		String feedback = MESSAGE_AFTER_ADD.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForAdd(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_ADD);
	}
			
	private Response addDeadlineTask() {
		String taskName = getDetailFromParameter(getNameParameter());
		assert !taskName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of deadline task: " + taskName);
		
		String date = getDetailFromParameter(getDateParameter());
		String time = getDetailFromParameter(getTimeParameter());
		
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details for deadline task");
		Response responseForAddDeadline = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(date, time);
		
		if (responseForAddDeadline.isSuccess()) {
			_logger.log(Level.INFO, "Start validating date time details for deadline task");
			responseForAddDeadline = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(date, time);
			if (responseForAddDeadline.isSuccess()) {
				_logger.log(Level.INFO, "Start processing deadline task for storage");
				responseForAddDeadline = processDeadlineTaskForStorage();  	                                               
			}
		}

		return responseForAddDeadline;
	}
	
	private Response processDeadlineTaskForStorage() {
		Entry deadlineTask = createDeadlineTask();
		_logger.log(Level.INFO, "Successfully created deadline task");
		Response responseForAddDeadline = updateNewEntryToStorage(deadlineTask);
		
		return responseForAddDeadline;
	}
	
	private Entry createDeadlineTask() {
		Entry deadlineTask = new Entry();		
		addParameterToEntry(deadlineTask, new Parameter(ParameterType.INDEX, ""));
		addParameterToEntry(deadlineTask, getNameParameter());
		addParameterToEntry(deadlineTask, getDateParameter());
		addParameterToEntry(deadlineTask, getTimeParameter());
		addParameterToEntry(deadlineTask, getPriorityParameter());
		addParameterToEntry(deadlineTask, getCategoryParameter());

		return deadlineTask;
	}
		
	private Response addEvent() {
		String eventName = getDetailFromParameter(getNameParameter());
		assert !eventName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of event: " + eventName);
		
		String startDate = getDetailFromParameter(getStartDateParameter());
		String startTime = getDetailFromParameter(getStartTimeParameter());
		String endDate = getDetailFromParameter(getEndDateParameter());
		String endTime = getDetailFromParameter(getEndTimeParameter());

		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details for event");
		Response responseForAddEvent = eventDateTimeProcessor.processEventDateTimeDetails(startDate, startTime, 
				                                                                          endDate, endTime);
		if (responseForAddEvent.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			endDate = startDate;
			_parameters.add(new Parameter(ParameterType.END_DATE, startDate));
		}
		
		// This implies date time details are in accepted event format and can proceed for validation
		if (responseForAddEvent.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating date time details for event");
			responseForAddEvent = eventDateTimeProcessor.validateEventDateTimeDetails(startDate, startTime, 
					                                                                  endDate, endTime);
			if (responseForAddEvent.isSuccess()) {
				_logger.log(Level.INFO, "Start processing event for storage");
				responseForAddEvent = processEventForStorage();
			}
		}

		return responseForAddEvent;
	}
		
	private Response processEventForStorage() {
		Entry event = createEvent();
		_logger.log(Level.INFO, "Successfully created event");
		Response responseForEvent = updateNewEntryToStorage(event);
		
		return responseForEvent;
	}
	
	private Entry createEvent() {
		Entry event = new Entry();
		addParameterToEntry(event, new Parameter(ParameterType.INDEX, ""));
		addParameterToEntry(event, getNameParameter());
		addParameterToEntry(event, getStartDateParameter());
		addParameterToEntry(event, getStartTimeParameter());
		addParameterToEntry(event, getEndDateParameter());
		addParameterToEntry(event, getEndTimeParameter());
		addParameterToEntry(event, getPriorityParameter());
		addParameterToEntry(event, getCategoryParameter());
		
		return event;
	}
}
```
###### src\com\taskboard\main\command\ArchiveCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Archive command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class ArchiveCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_EMPTY_ARCHIVE = "There are no completed entries.";
	private static final String MESSAGE_RETRIEVE_ARCHIVE_SUCCESS = "Successfully retrieved all archived entries.";  

	public ArchiveCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForArchive = new Response();
		responseForArchive.setIsSuccess(true);
		ArrayList<Entry> entries = _tempStorageManipulator.getTempArchive();
		responseForArchive.setEntries(entries);
		if (entries.isEmpty()) {
			responseForArchive.setFeedback(MESSAGE_EMPTY_ARCHIVE);
		} else {
			responseForArchive.setFeedback(MESSAGE_RETRIEVE_ARCHIVE_SUCCESS);
		}
		
		_logger.log(Level.INFO, "Generated success response for accessing archive");
		
		return responseForArchive;
	}	
}
```
###### src\com\taskboard\main\command\Command.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Logger;

import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/**
 * This class is an abstract class that is inherited by the relevant commands.
 * CommandParser creates the command class corresponding to the command specified
 * by the user input.
 * @author Amarparkash Singh Mavi
 *
 */
public abstract class Command {
	
	// attributes
	
	/** This class attribute is an instance of the tempStorageManipulator class which manipulates the 
	 *  temporary storage of entries based on the command executed.
	 */
	protected static TempStorageManipulator _tempStorageManipulator;
	
	/** This attribute is the ArrayList of parameter objects returned by CommandParser, corresponding 
	 *  to the details input by the user.
	 */
	protected ArrayList<Parameter> _parameters;
	
	protected Logger _logger;
	
	// accessors
		
	public ArrayList<Parameter> getParameters() {
		return _parameters;
	}
	
	public TempStorageManipulator getTempStorageManipulator() {
		return _tempStorageManipulator;
	}
	
	public Parameter getIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
		
	public Parameter getNewNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NEW_NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getPriorityParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getCategoryParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	// mutators
	
	public void setParameters(ArrayList<Parameter> newParameters) {
		_parameters = newParameters;
	}
	
	public void setIndexParameter(Parameter newIndexParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.set(i, newIndexParameter);
			}
		}
	}
		
	public void setNameParameter(Parameter newNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				_parameters.set(i, newNameParameter);
			}
		}
	}
		
	public void setNewNameParameter(Parameter newNewNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NEW_NAME) {
				_parameters.set(i, newNewNameParameter);
			}
		}
	}
	
	public void setDateParameter(Parameter newDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				_parameters.set(i, newDateParameter);
			}
		}
	}
	
	public void setTimeParameter(Parameter newTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				_parameters.set(i, newTimeParameter);
			}
		}
	}
	
	public void setStartDateParameter(Parameter newStartDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				_parameters.set(i, newStartDateParameter);
			}
		}
	}
	
	public void setStartTimeParameter(Parameter newStartTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				_parameters.set(i, newStartTimeParameter);
			}
		}
	}
	
	public void setEndDateParameter(Parameter newEndDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				_parameters.set(i, newEndDateParameter);
			}
		}
	}
	
	public void setEndTimeParameter(Parameter newEndTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				_parameters.set(i, newEndTimeParameter);
			}
		}
	}
	
	public void setPriorityParameter(Parameter newPriorityParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				_parameters.set(i, newPriorityParameter);
			}
		}
	}
	
	public void setCategoryParameter(Parameter newCategoryParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				_parameters.set(i, newCategoryParameter);
			}
		}
	}
	
	// other functionalities
	
	public String getDetailFromParameter(Parameter parameter) {
		String detail = "";
		if (parameter != null) {
			detail = parameter.getParameterValue();
		}
		
		return detail;
	}
	
	/** 
	 * This is an abstract method that is implemented by the respective commands that
	 * inherit from the Command class. It executes the respective command and returns
	 * a Response based on the success of the operation.
	 * 
	 * @return Response.
	 */
	public abstract Response executeCommand(); 	
}
```
###### src\com\taskboard\main\command\CompleteCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Complete command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class CompleteCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_AFTER_COMPLETE = "Entry successfully indicated as completed:";
	private static final String MESSAGE_ERROR_FOR_COMPLETE = "The entry could not be indicated as completed.";
	
	public CompleteCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		// _parameters must have the index of entry to be completed for Complete command to be valid
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of CompleteCommand");
		
		// facilitates the Undo command
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		// facilitates the Undo command
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		IndexProcessor indexProcessorForComplete = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForComplete = indexProcessorForComplete.processInputIndex(_parameters, entries);
		
		if (responseForComplete.isSuccess()) {
			_logger.log(Level.INFO, "Start process of indicating entry completion");
			responseForComplete = processEntryCompletion();
		}
		
		// facilitates the Undo command
		if (responseForComplete.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForComplete;
	}
		
	private Response processEntryCompletion() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempStorageIndex = indexValue - 1;
		Response responseForComplete = new Response();
		try {
			Entry entryToComplete = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			Entry entryBeforeComplete = new Entry(entryToComplete);
			_tempStorageManipulator.setCompletedInTempStorage(tempStorageIndex);
			setSuccessResponseForComplete(responseForComplete, entryBeforeComplete);
			_logger.log(Level.INFO, "Generated success response for indicating entry completion");
		} catch (IOException ex) {
			setFailureResponseForComplete(responseForComplete);
			_logger.log(Level.INFO, "Generated failure response for indicating entry completion");
		}
		
		return responseForComplete;
	}
	
	private void setSuccessResponseForComplete(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulComplete(entry);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulComplete(Entry entry) {
		String feedback = MESSAGE_AFTER_COMPLETE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForComplete(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_COMPLETE);
	}
}
```
###### src\com\taskboard\main\command\DeleteCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.SelectiveFilterProcessor;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Delete command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class DeleteCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_AFTER_DELETE = "Entry successfully deleted:";
	private static final String MESSAGE_ERROR_FOR_DELETE = "The deletion was unsuccessful.";
	
	public DeleteCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		/* _parameters must minimally have the index of entry to be deleted 
		 * or a filter constraint for the Delete command to be valid
		 */
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of DeleteCommand");
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		Response responseForDelete = new Response();
		if (isDeleteByIndex()) {
			IndexProcessor indexProcessorForDelete = new IndexProcessor();
			ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
			responseForDelete = indexProcessorForDelete.processInputIndex(_parameters, entries);
			
			if (!responseForDelete.isSuccess()) {
				return responseForDelete;
			}
			
			_logger.log(Level.INFO, "Start processing delete by index");
			responseForDelete = processDeleteByIndex();
		} else {
			_logger.log(Level.INFO, "Start processing delete by filtering");
			responseForDelete = processDeleteByFiltering();
		}
		
		// facilitates the Undo command 
		if (responseForDelete.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForDelete;
	}
	
	private boolean isDeleteByIndex() {
		Parameter indexParameter = getIndexParameter();
		if (indexParameter != null) {
			return true;
		}
		
		return false; 
	}
		
	private Response processDeleteByIndex() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempStorageIndex = indexValue - 1;
		Response responseForDeleteByIndex = new Response();
		try {
			Entry entryToDelete = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			_tempStorageManipulator.deleteFromTempStorage(tempStorageIndex);
			setSuccessResponseForDeleteByIndex(responseForDeleteByIndex, entryToDelete);
			_logger.log(Level.INFO, "Generated success response for delete by index");
		} catch (IOException ex) {
			setFailureResponseForDelete(responseForDeleteByIndex);
			_logger.log(Level.INFO, "Generated failure response for delete by index");
		}
		
		return responseForDeleteByIndex;
	}
	
	private void setSuccessResponseForDeleteByIndex(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulDeleteByIndex(entry);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulDeleteByIndex(Entry entry) {
		String feedback = MESSAGE_AFTER_DELETE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForDelete(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_DELETE);
	}
	
	private Response processDeleteByFiltering() {
		SelectiveFilterProcessor selectiveFilterProcessor = new SelectiveFilterProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForFiltering = selectiveFilterProcessor.processFiltering(entries, _parameters);
		ArrayList<Entry> filteredEntries = selectiveFilterProcessor.getFilteredEntries();
		try {
			if (!filteredEntries.isEmpty()) {
				_tempStorageManipulator.deleteFromTempStorage(filteredEntries);
			}
			
			setSuccessResponseForDeleteByFiltering(responseForFiltering, filteredEntries);
			_logger.log(Level.INFO, "Generated success response for delete by filtering");
			
			return responseForFiltering;
		} catch (IOException ex) {
			Response failedResponseForDelete = new Response();
			setFailureResponseForDelete(failedResponseForDelete);
			_logger.log(Level.INFO, "Generated failure response for delete by filtering");
			
			return failedResponseForDelete;
		}
	}
	
	private void setSuccessResponseForDeleteByFiltering(Response response, ArrayList<Entry> filteredEntries) {
		String userFeedback = response.getFeedback().replace("found", "deleted");
		userFeedback = userFeedback.replace(".", ":");
		userFeedback = userFeedback.concat("<br>");
		for (int i = 0; i < filteredEntries.size(); i++) {
			Entry entry = filteredEntries.get(i);
			userFeedback = userFeedback.concat("<br>").concat(entry.toHTMLString());
		}
		
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
}
```
###### src\com\taskboard\main\command\EditCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.DateTimeProcessor;
import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Edit command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class EditCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_AFTER_EDIT = "Entry successfully updated:";
	private static final String MESSAGE_FOR_UPDATED_ENTRY = "Entry after update =>";
	private static final String MESSAGE_FOR_OLD_ENTRY = "Entry before update =>";
	private static final String MESSAGE_ERROR_FOR_EDIT = "The entry could not be edited.";

	public EditCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		/* _parameters should minimally have the index of the entry to be edited 
		 *  and a edited detail for the Edit command to be valid
		 */
		assert _parameters.size() > 1;
		_logger.log(Level.INFO, "Commence execution of EditCommand");
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		// facilitates the Undo command 
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
				
		IndexProcessor indexProcessorForEdit = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForEdit = indexProcessorForEdit.processInputIndex(_parameters, entries);
		
		if (responseForEdit.isSuccess()) {
			_logger.log(Level.INFO, "Start process of editing entry");
			responseForEdit = processEditedDetailsForStorage();
		}
		
		// facilitates the Undo command 
		if (responseForEdit.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		 
		return responseForEdit;
	}
	
	private Response processEditedDetailsForStorage() {
		ArrayList<Parameter> editedParameters = new ArrayList<Parameter>();
		Parameter newNameParameter = getNewNameParameter();
		if (newNameParameter != null) {
			newNameParameter.setParameterType(ParameterType.NAME);
			editedParameters.add(newNameParameter);
		}
		
		Parameter priorityParameter = getPriorityParameter();
		if (priorityParameter != null) {
			editedParameters.add(priorityParameter);
		}
		
		Parameter categoryParameter = getCategoryParameter();
		if (categoryParameter != null) {
			editedParameters.add(categoryParameter);
		}
		
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.valueOf(index);
		Response responseForEdit = new Response();
		
		if (isEditDateTimeForDeadlineTask()) {
			_logger.log(Level.INFO, "Start processing edited date time details for deadline task");
			responseForEdit = processEditedDateTimeDetailsForDeadlineTask(editedParameters, indexValue);
		} else if (isEditDateTimeForEvent()) {
			_logger.log(Level.INFO, "Start processing edited date time details for event");
			responseForEdit = processEditedDateTimeDetailsForEvent(editedParameters, indexValue);
		} else {
			boolean isEntryTypeChanged = false;
			_logger.log(Level.INFO, "Start processing edited details for storage");
			responseForEdit = updateEditedDetailsToStorage(editedParameters, indexValue, isEntryTypeChanged);
		}
		
		return responseForEdit;
	}
	
	private boolean isEditDateTimeForDeadlineTask() {
		Parameter dateParameter = getDateParameter();
		Parameter timeParameter = getTimeParameter();
		if (dateParameter != null || timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processEditedDateTimeDetailsForDeadlineTask(ArrayList<Parameter> editedParameters, 
			                                                     int index) {
		String newDate = getDetailFromParameter(getDateParameter());
		String newTime = getDetailFromParameter(getTimeParameter());
		Response responseForDateTime = new Response();
		
		if (isEditedEntryFloatingTask(index) || isEditedEntryEvent(index)) {
			_logger.log(Level.INFO, "Start process of converting existing entry to deadline task");
			responseForDateTime = processConversionToDeadlineTask(editedParameters, index, newDate, newTime);							                                                              
		} else if (isEditedEntryDeadlineTask(index)) {
			_logger.log(Level.INFO, "Start process of editing existing deadline task");
			responseForDateTime = processEditingDeadlineTask(editedParameters, index, newDate, newTime);
		} 
				
		return responseForDateTime;
	}
	
	private boolean isEditedEntryFloatingTask(int index) {
		if (!isEditedEntryDeadlineTask(index) && !isEditedEntryEvent(index)) {
			return true;
		}
		
		return false;
	}
	
	private boolean isEditedEntryDeadlineTask(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter dateParameter = entry.getDateParameter();
		if (dateParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private boolean isEditedEntryEvent(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startDateParameter = entry.getStartDateParameter();
		if (startDateParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processConversionToDeadlineTask(ArrayList<Parameter> editedParameters, int index, 
			                                         String newDate, String newTime) {
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		Response responseForDateTime = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(newDate, 
				                                                                                newTime);
		
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Start validating edited date time details for deadline task");
			responseForDateTime = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(newDate, newTime);
			if (responseForDateTime.isSuccess()) {
				boolean isEntryTypeChanged = true;
				responseForDateTime = addEditedDateTimeParametersForDeadlineTask(editedParameters, index,  
						                                                         isEntryTypeChanged);
			}
		}
		
		return responseForDateTime;
	}
	
	private Response addEditedDateTimeParametersForDeadlineTask(ArrayList<Parameter> editedParameters, 
			                                                    int index, boolean isEntryTypeChanged) {
		addParameterToEditedParameters(editedParameters, getDateParameter());
		addParameterToEditedParameters(editedParameters, getTimeParameter());
		
		_logger.log(Level.INFO, "Start processing edited details for storage");
		Response responseForDateTime = updateEditedDetailsToStorage(editedParameters, index, 
				                                                    isEntryTypeChanged);
		
		return responseForDateTime;
	}
	
	private void addParameterToEditedParameters(ArrayList<Parameter> editedParameters, Parameter parameter) {
		if (parameter != null) {
			editedParameters.add(parameter);
		}
	}
		
	private Response processEditingDeadlineTask(ArrayList<Parameter> editedParameters, int index, 
			                                    String newDate, String newTime) {
		if (newDate.isEmpty()) {
			newDate = getDateFromEntry(index);
			_parameters.add(new Parameter(ParameterType.DATE, newDate));
		}
		
		if (newTime.isEmpty()) {
			newTime = getTimeFromEntry(index);
			_parameters.add(new Parameter(ParameterType.TIME, newTime));
		}
		
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start validating edited date time details for deadline task");
		Response responseForDateTime = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(newDate, 
				                                                                                 newTime);
		if (responseForDateTime.isSuccess()) {
			boolean isEntryTypeChanged = false;
			responseForDateTime = addEditedDateTimeParametersForDeadlineTask(editedParameters, index,  
					                                                         isEntryTypeChanged);
		}
		
		return responseForDateTime;
	}
	
	private String getDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter dateParameter = entry.getDateParameter();
		String date = dateParameter.getParameterValue();
		
		return date;
	}
	
	private String getTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter timeParameter = entry.getTimeParameter();
		String time = "";
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
		 
		return time;
	}
		
	private boolean isEditDateTimeForEvent() {
		Parameter startDateParameter = getStartDateParameter();
		Parameter startTimeParameter = getStartTimeParameter();
		Parameter endDateParameter = getEndDateParameter();
		Parameter endTimeParameter = getEndTimeParameter();
		if (startDateParameter != null || startTimeParameter != null || 
		    endDateParameter != null || endTimeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processEditedDateTimeDetailsForEvent(ArrayList<Parameter> editedParameters, int index) {
		String newStartDate = getDetailFromParameter(getStartDateParameter());
		String newStartTime = getDetailFromParameter(getStartTimeParameter());
		String newEndDate = getDetailFromParameter(getEndDateParameter());
		String newEndTime = getDetailFromParameter(getEndTimeParameter());
		Response responseForDateTime = new Response();
		
		if (isEditedEntryFloatingTask(index) || isEditedEntryDeadlineTask(index)) {
			_logger.log(Level.INFO, "Start process of converting existing entry to event");
			responseForDateTime = processConversionToEvent(editedParameters, index, newStartDate, newStartTime,
					                                       newEndDate, newEndTime);							                                                              
		} else if (isEditedEntryEvent(index)) {
			_logger.log(Level.INFO, "Start process of editing existing event");
			responseForDateTime = processEditingEvent(editedParameters, index, newStartDate, newStartTime,
					                                  newEndDate, newEndTime);		 
		} 
			
		return responseForDateTime;
	}
	
	private Response processConversionToEvent(ArrayList<Parameter> editedParameters, int index, 
			                                  String newStartDate, String newStartTime, String newEndDate, 
			                                  String newEndTime) {
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		Response responseForDateTime = eventDateTimeProcessor.processEventDateTimeDetails(newStartDate, newStartTime, 
				                                                                          newEndDate, newEndTime);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			newEndDate = newStartDate;
			_parameters.add(new Parameter(ParameterType.END_DATE, newStartDate));
		}
		
		// This implies date time details are in accepted event format and can proceed for validation
		if (responseForDateTime.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating edited date time details for event");
			responseForDateTime = eventDateTimeProcessor.validateEventDateTimeDetails(newStartDate, newStartTime, 
					                                                                  newEndDate, newEndTime);
			if (responseForDateTime.isSuccess()) {
				boolean isEntryTypeChanged = true;
				responseForDateTime = addEditedDateTimeParametersForEvent(editedParameters, index, 
						                                                  isEntryTypeChanged);
			}
		}
		
		return responseForDateTime;
	}
	
	private Response addEditedDateTimeParametersForEvent(ArrayList<Parameter> editedParameters, int index,
			                                             boolean isEntryTypeChanged) {                      
		addParameterToEditedParameters(editedParameters, getStartDateParameter());
		addParameterToEditedParameters(editedParameters, getStartTimeParameter());
		addParameterToEditedParameters(editedParameters, getEndDateParameter());
		addParameterToEditedParameters(editedParameters, getEndTimeParameter());
		
		_logger.log(Level.INFO, "Start processing edited details for storage");
		Response responseForDateTime = updateEditedDetailsToStorage(editedParameters, index, 
				                                                    isEntryTypeChanged);
		
		return responseForDateTime;
	}
	
	private Response processEditingEvent(ArrayList<Parameter> editedParameters, int index, String newStartDate,
			                             String newStartTime, String newEndDate, String newEndTime) {
		if (newStartDate.isEmpty()) {
			newStartDate = getStartDateFromEntry(index);
			_parameters.add(new Parameter(ParameterType.START_DATE, newStartDate));
		}
		
		if (newStartTime.isEmpty()) {
			newStartTime = getStartTimeFromEntry(index);
			_parameters.add(new Parameter(ParameterType.START_TIME, newStartTime));
		}
		
		if (newEndDate.isEmpty()) {
			newEndDate = getEndDateFromEntry(index);
			_parameters.add(new Parameter(ParameterType.END_DATE, newEndDate));
		}
		
		if (newEndTime.isEmpty()) {
			newEndTime = getEndTimeFromEntry(index);
			_parameters.add(new Parameter(ParameterType.END_TIME, newEndTime));
		}
		
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start validating edited date time details for event");
		Response responseForDateTime = eventDateTimeProcessor.validateEventDateTimeDetails(newStartDate, newStartTime, 
				                                                                           newEndDate, newEndTime);
		if (responseForDateTime.isSuccess()) {
			boolean isEntryTypeChanged = false;
			responseForDateTime = addEditedDateTimeParametersForEvent(editedParameters, index, 
					                                                  isEntryTypeChanged);
		}
		
		return responseForDateTime;
	}
	
	private String getStartDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startDateParameter = entry.getStartDateParameter();
		String startDate = startDateParameter.getParameterValue();
	
		return startDate;
	}
	
	private String getStartTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startTimeParameter = entry.getStartTimeParameter();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		 
		return startTime;
	}
	
	private String getEndDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter endDateParameter = entry.getEndDateParameter();
		String endDate = endDateParameter.getParameterValue();
	
		return endDate;
	}
	
	private String getEndTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter endTimeParameter = entry.getEndTimeParameter();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		 
		return endTime;
	}
	
	private Response updateEditedDetailsToStorage(ArrayList<Parameter> editedParameters, int index,
			                                      boolean isEntryTypeChanged) {
		Response responseForEdit = new Response();
		try {
			int tempStorageIndex = index - 1;
			Entry oldEntry = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			Entry entryBeforeUpdate = new Entry(oldEntry);
			Entry entryAfterUpdate = _tempStorageManipulator.editTempStorage(tempStorageIndex, editedParameters,
					                                                         isEntryTypeChanged); 
			setSuccessResponseForEdit(responseForEdit, entryBeforeUpdate, entryAfterUpdate);
			_logger.log(Level.INFO, "Generated success response for editing entry");
		} catch (IOException ex) {
			setFailureResponseForEdit(responseForEdit);
			_logger.log(Level.INFO, "Generated failure response for editing entry");
		}
		
		return responseForEdit;
	}

	private void setSuccessResponseForEdit(Response response, Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate, entryAfterUpdate);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulEdit(Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		String feedback = MESSAGE_AFTER_EDIT.concat("<br>").concat("<br>").concat(MESSAGE_FOR_UPDATED_ENTRY);
		feedback = feedback.concat("<br>").concat(entryAfterUpdate.toHTMLString());
		feedback = feedback.concat("<br>").concat(MESSAGE_FOR_OLD_ENTRY);
		feedback = feedback.concat("<br>").concat(entryBeforeUpdate.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForEdit(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_EDIT);
	}
}
```
###### src\com\taskboard\main\command\InvalidCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and returns a corresponding Response
 * for invalid command types input by the user.
 * @author Amarparkash Singh Mavi
 *
 */
public class InvalidCommand extends Command {
	
	// This is the feedback message to be displayed to the user
	private static final String MESSAGE_ERROR_INVALID_COMMAND = "Invalid command type provided.";
	
	public InvalidCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForInvalidCommand = new Response();
		responseForInvalidCommand.setIsSuccess(false);
		responseForInvalidCommand.setFeedback(MESSAGE_ERROR_INVALID_COMMAND);
		_logger.log(Level.INFO, "Generated failure response for invalid command");
		
		return responseForInvalidCommand;
	}
}
```
###### src\com\taskboard\main\command\NewCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the New command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class NewCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_ERROR_FOR_LAUNCH_NEW = "Failed to create new file.";
	
	private static final String TITLE_AFTER_LAUNCH = "TaskBoard: Your Revolutionary Task Manager (%1$s)";
	
	public NewCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		// _parameters must have the name of the file to be created for New command to be valid
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of NewCommand");
		
		String fileName = getDetailFromParameter(getNameParameter());
		assert fileName != null;
		_logger.log(Level.INFO, "Successfully retrieved filename: " + fileName);
		Response responseForNew = getResponseForLaunch(fileName);
		
		return responseForNew;
	}
	
	private Response getResponseForLaunch(String fileName) {
		Response responseForNew = new Response();
		try {
			_tempStorageManipulator.initialise(fileName);
			updateUIPreferences();
			updateUITitle(fileName);
			setSuccessResponseForLaunchNew(responseForNew, fileName);
			_logger.log(Level.INFO, "Generated success response for creating new file");
		} catch (IllegalArgumentException ex) {
			setFailureResponseForInvalidNew(responseForNew, ex);
			_logger.log(Level.INFO, "Generated failure response for creating new file with "
					    + "existing filename");
		} catch (IOException ex) {
			setFailureResponseForLaunchNew(responseForNew);
			_logger.log(Level.INFO, "Generated failure response for creating new file");
		}
		
		return responseForNew;
	}
	
	private void setSuccessResponseForLaunchNew(Response response, String fileName) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulLaunchNew(fileName);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulLaunchNew(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	private void setFailureResponseForInvalidNew(Response response, IllegalArgumentException ex) {
		response.setIsSuccess(false);
		response.setFeedback(ex.getMessage());
	}
	
	private void setFailureResponseForLaunchNew(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_LAUNCH_NEW);
	}
	
	private void updateUIPreferences() throws IOException {
		String backgroundPath = _tempStorageManipulator.getBackgroundPath();
		UserInterface.getInstance().setBackgroundPath(backgroundPath);
		
		int reminderHour = _tempStorageManipulator.getReminderHour();
		UserInterface.getInstance().setReminderHour(reminderHour);
	}

	private void updateUITitle(String title) {
		UserInterface.getInstance().setTitle(String.format(TITLE_AFTER_LAUNCH, title));
	}
}
```
###### src\com\taskboard\main\command\OpenCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Open command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class OpenCommand extends Command{
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_ERROR_FOR_LAUNCH_OPEN = "Failed to open file.";
	
	private static final String TITLE_AFTER_LAUNCH = "TaskBoard: Your Revolutionary Task Manager (%1$s)";
	
	public OpenCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		// _parameters must have the name of the file to be opened for Open command to be valid
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of OpenCommand");
		
		String fileName = getDetailFromParameter(getNameParameter());
		assert fileName != null;
		_logger.log(Level.INFO, "Successfully retrieved filename: " + fileName);
		Response responseForOpen =  getResponseForLaunch(fileName);
		
		return responseForOpen;
	}
	
	private Response getResponseForLaunch(String fileName) {
		Response responseForOpen = new Response();	
		try {
			_tempStorageManipulator.repopulate(fileName);
			updateUIPreferences();
			updateUITitle(fileName);
			setSuccessResponseForLaunchOpen(responseForOpen, fileName);
			_logger.log(Level.INFO, "Generated success response for opening existing file");
		} catch (IllegalArgumentException ex) {
			setFailureResponseForInvalidOpen(responseForOpen, ex);
			_logger.log(Level.INFO, "Generated failure response for opening non-existent file");
		} catch (IOException ex) {
			setFailureResponseForLaunchOpen(responseForOpen);
			_logger.log(Level.INFO, "Generated failure response for opening existing file");
		}
	
		return responseForOpen;
	}
	
	private void setSuccessResponseForLaunchOpen(Response response, String fileName) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulLaunchOpen(fileName);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulLaunchOpen(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	private void setFailureResponseForInvalidOpen(Response response, IllegalArgumentException ex) {
		response.setIsSuccess(false);
		response.setFeedback(ex.getMessage());
	}
	
	private void setFailureResponseForLaunchOpen(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_LAUNCH_OPEN);
	}
	
	private void updateUIPreferences() throws IOException {
		String backgroundPath = _tempStorageManipulator.getBackgroundPath();
		UserInterface.getInstance().setBackgroundPath(backgroundPath);
		
		int reminderHour = _tempStorageManipulator.getReminderHour();
		UserInterface.getInstance().setReminderHour(reminderHour);
	}

	private void updateUITitle(String title) {
		UserInterface.getInstance().setTitle(String.format(TITLE_AFTER_LAUNCH, title));
	}
}
```
###### src\com\taskboard\main\command\RestoreCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the Restore command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class RestoreCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_AFTER_RESTORE = "Entry successfully restored:";
	private static final String MESSAGE_ERROR_FOR_RESTORE = "The entry could not be restored.";
	
	public RestoreCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		// _parameters must have the index of entry to be restored for Restore command to be valid
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commence execution of RestoreCommand");
		
		// facilitates the Undo command
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		// facilitates the Undo command
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		IndexProcessor indexProcessorForRestore = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempArchive();
		Response responseForRestore = indexProcessorForRestore.processInputIndex(_parameters, entries);
		
		if (responseForRestore.isSuccess()) {
			_logger.log(Level.INFO, "Start process of restoring entry");
			responseForRestore = processRestoringOfEntry();
		}
		
		// facilitates the Undo command
		if (responseForRestore.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForRestore;
	}
	
	private Response processRestoringOfEntry() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempArchiveIndex = indexValue - 1;
		Response responseForRestore = new Response();
		try {
			Entry entryToRestore = _tempStorageManipulator.getTempArchive().get(tempArchiveIndex);
			Entry entryBeforeRestore = new Entry(entryToRestore);
			_tempStorageManipulator.restoreToTempStorage(tempArchiveIndex);
			setSuccessResponseForRestore(responseForRestore, entryBeforeRestore);
			_logger.log(Level.INFO, "Generated success response for restoring entry");
		} catch (IOException ex) {
			setFailureResponseForRestore(responseForRestore);
			_logger.log(Level.INFO, "Generated failure response for restoring entry");
		}
		
		return responseForRestore;
	}
	
	private void setSuccessResponseForRestore(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulRestore(entry);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempArchive());
	}
	
	private String getFeedbackForSuccessfulRestore(Entry entry) {
		String feedback = MESSAGE_AFTER_RESTORE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForRestore(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_RESTORE);
	}
}
```
###### src\com\taskboard\main\command\ViewCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.SelectiveFilterProcessor;
import com.taskboard.main.TempStorageManipulator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class inherits from the Command class and executes the View command.
 * It returns a corresponding Response that denotes the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class ViewCommand extends Command {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_EMPTY_ENTRY_LIST = "There are no registered entries.";
	private static final String MESSAGE_RETRIEVE_ENTRIES_SUCCESS = "Successfully retrieved all entries.";

	public ViewCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	 
	public Response executeCommand() {
		_logger.log(Level.INFO, "Commence execution of ViewCommand");
		Response responseForView = new Response();
		if (isViewWithoutFilter()) {
			setSuccessResponseForViewWithoutFilter(responseForView);
			_logger.log(Level.INFO, "Generated success response for view without filter");
		} else {
			_logger.log(Level.INFO, "Start processing view with filter");
			SelectiveFilterProcessor selectiveFilterProcessor = new SelectiveFilterProcessor();
			ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
			responseForView = selectiveFilterProcessor.processFiltering(entries, _parameters);
		}
		
		return responseForView;
	}
	
	private boolean isViewWithoutFilter() {
		if (_parameters.isEmpty()) {
			return true;
		}
		
		return false;
	}
	
	private void setSuccessResponseForViewWithoutFilter(Response response) {
		response.setIsSuccess(true);
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		response.setEntries(entries);
		if (entries.isEmpty()) {
			response.setFeedback(MESSAGE_EMPTY_ENTRY_LIST);
		} else {
			response.setFeedback(MESSAGE_RETRIEVE_ENTRIES_SUCCESS);
		}
	}
}
```
###### src\com\taskboard\main\DateTimeProcessor.java
``` java
package com.taskboard.main;

import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Response;

/**
 * This class processes and validates the provided date time details in deadline or event format.
 * It returns the corresponding Response upon verification.
 * @author Amarparkash Singh Mavi
 *
 */
public class DateTimeProcessor {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_ERROR_FOR_NO_VALID_DATE = "No valid date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_VALID_START_DATE = "No valid start date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_VALID_END_DATE_TIME = "No valid end date time provided.";
	
	// attribute
	
	private Logger _logger;
	
	// constructor
	
	public DateTimeProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// other functionalities
	
	/**
	 * This method verifies if the date time details are in the accepted deadline format
	 * and returns a corresponding Response upon verification. 
	 * 
	 * @param date Date in string format. 
	 * @param time Time in string format.
	 * @return     Response.   
	 */
	public Response processDeadlineDateTimeDetails(String date, String time) {
		Response responseForDateTime = new Response();
		if (date.isEmpty()) {
			setFailureResponseForNoDate(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no date");
		} else {
			responseForDateTime.setIsSuccess(true);
		}
		
		return responseForDateTime;
	}
	
	private void setFailureResponseForNoDate(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_VALID_DATE);
	}
	
	/** 
	 * This method validates the date time details in the deadline format and returns a
	 * corresponding Response upon verification.
	 * 
	 * @param date Date in string format.
	 * @param time Time in string format.
	 * @return     Response. 
	 */
	public Response validateDeadlineDateTimeDetails(String date, String time) {
		DateTimeValidator deadlineDateTimeValidator = new DateTimeValidator();
		Date currentDate = new Date();
		Response responseForDateTime = deadlineDateTimeValidator.validateDateTimeDetails(date, time, 
				                                                                         currentDate);
		
		return responseForDateTime;
	}
	
	/**
	 * This method verifies if the date time details are in the accepted event format and
	 * returns a corresponding Response upon verification.
	 *   
	 * @param startDate Start date in string format. 
	 * @param startTime Start time in string format.
	 * @param endDate   End date in string format.
	 * @param endTime   End time in string format.
	 * @return          Response.
	 */
	public Response processEventDateTimeDetails(String startDate, String startTime, String endDate, 
			                                    String endTime) {
		Response responseForDateTime = new Response();
		if (startDate.isEmpty()) {
			setFailureResponseForNoStartDate(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no start date");
		} else if (endDate.isEmpty() && endTime.isEmpty()) {
			setFailureResponseForNoEndDateTime(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no end date time");
		} else if (endDate.isEmpty()) {
			responseForDateTime.setIsSuccess(true);
		}
		
		return responseForDateTime;
	}
	
	private void setFailureResponseForNoStartDate(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_VALID_START_DATE);
	}
	
	private void setFailureResponseForNoEndDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_VALID_END_DATE_TIME);
	}
	
	/**
	 * This method validates the date time details in the event format and returns a
	 * corresponding Response upon verification.
	 * 
	 * @param startDate Start date in string format. 
	 * @param startTime Start time in string format.
	 * @param endDate   End date in string format.
	 * @param endTime   End time in string format.
	 * @return          Response.
	 */
	public Response validateEventDateTimeDetails(String startDate, String startTime, String endDate, 
			                                     String endTime) {
		DateTimeValidator startDateTimeValidator = new DateTimeValidator();
		Date currentDate = new Date();
		Response responseForDateTime = startDateTimeValidator.validateDateTimeDetails(startDate, startTime, 
				                                                                      currentDate);
		
		if (responseForDateTime.isSuccess() == true) {
			DateTimeValidator endDateTimeValidator = new DateTimeValidator();
			Date inputStartDate = startDateTimeValidator.getDate();
			responseForDateTime = endDateTimeValidator.validateDateTimeDetails(endDate, endTime, inputStartDate);
		}
		
		return responseForDateTime;
	}
}
```
###### src\com\taskboard\main\DateTimeValidator.java
``` java
package com.taskboard.main;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Response;

/**
 * This class validates the provided date time details and creates a corresponding Date object
 * if the details are valid. If a reference Date is provided, it goes on to verify the currency
 * of the created Date against the reference Date. It returns a corresponding Response upon
 * verification.
 * @author Amarparkash Singh Mavi
 *
 */
public class DateTimeValidator {
	
	// These are the feedback messages to be displayed to the user
	private static final String MESSAGE_ERROR_FOR_INVALID_DATE_TIME = "Invalid date time provided.";
	private static final String MESSAGE_ERROR_FOR_PAST_DATE_TIME = "Past date time provided.";
	
	// This is the default time format assigned during validation, if no time detail is provided
	private static final String FORMAT_DEFAULT_TIME = "23:59";
	
	// This is the date time format used when validating the date time details
	private static final String FORMAT_DATE_TIME = "dd/MM/yyyy'T'HH:mm";
	
	// attributes
	
	/** This attribute is the Date object created if the provided date time details are valid.*/
	private Date _inputDate;
	
	private Logger _logger;
	
	// constructor
	
	public DateTimeValidator() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// accessor
	
	public Date getDate() {
		return _inputDate;
	}
	
	// other functionalities
	
	/** 
	 * This method validates the date time details provided. If the details are valid, 
	 * it creates a Date object that initialises _inputDate. If referenceDate is not null,
	 * it goes on to verify the currency of the created Date against referenceDate.
	 * It returns the corresponding Response upon verification.
	 * 
	 * @param date			Date in string format.
	 * @param time          Time in string format.
	 * @param referenceDate Date to be compared against.
	 * @return				Response.
	 */
	public Response validateDateTimeDetails(String date, String time, Date referenceDate) {
		String dateTime = getDateTimeFormat(date, time);
		_inputDate = getInputDate(dateTime);
		Response responseForDateTime = new Response();
		
		if (_inputDate == null) {
			setFailureResponseForInvalidDateTime(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for invalid date time");
		} else if (referenceDate != null){
			responseForDateTime = checkCurrencyOfInputDate(referenceDate);
		}
		
		return responseForDateTime;
	}
	
	private String getDateTimeFormat(String date, String time) {
		if (time.isEmpty()) {
			time = FORMAT_DEFAULT_TIME;
		}
		
		String dateTime = date.concat("T").concat(time);
		
		return dateTime;
	}
	
	private Date getInputDate(String dateTime) {
		 try {
			 DateFormat dateFormat = new SimpleDateFormat(FORMAT_DATE_TIME);
	         dateFormat.setLenient(false);
	         Date inputDate = dateFormat.parse(dateTime);
 	         
	         return inputDate;
	     } catch (ParseException e) {
	         return null;
	     }
	}
	
	private void setFailureResponseForInvalidDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_INVALID_DATE_TIME);
	}
	
	private Response checkCurrencyOfInputDate(Date referenceDate) {
		Response responseForInputDate = new Response();
		if (_inputDate.after(referenceDate)) {
			responseForInputDate.setIsSuccess(true);
		} else {
			setFailureResponseForPastDateTime(responseForInputDate);
			_logger.log(Level.INFO, "Generated failure response for past date time");
		}
			
		return responseForInputDate;
	}
	
	private void setFailureResponseForPastDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
	}
}
```
###### src\com\taskboard\main\IndexProcessor.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/**
 * This class retrieves the entry index to be processed and validates it. 
 * It returns a corresponding Response upon verification.
 * @author Amarparkash Singh Mavi
 *
 */
public class IndexProcessor {
	
	// This is the feedback message to be displayed to the user
	private static final String MESSAGE_ERROR_FOR_INVALID_INDEX = "Invalid index provided.";
	
	// This is the minimum index value a Entry can have
	private static final int MIN_ENTRY_INDEX = 1;
	
	// attribute
	
	private Logger _logger;
	
	// constructor
	
	public IndexProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// other functionalities
	
	/**
	 * This method retrieves the entry index to be processed from parameters and 
	 * validates it. It returns a corresponding Response upon verification.
	 * 
	 * @param parameters ArrayList of parameter objects containing the index parameter.
	 * @param entries    ArrayList of entry objects that represents the current entries registered.
	 * @return			 Response.
	 */
	public Response processInputIndex(ArrayList<Parameter> parameters, ArrayList<Entry> entries) {
		String inputIndex = "";
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.INDEX) {
				inputIndex = parameters.get(i).getParameterValue(); 
			}
		}
		
		assert !inputIndex.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved index of entry: " + inputIndex);
		Response responseForInputIndex = checkValidityOfInputIndex(inputIndex, entries);
		
		return responseForInputIndex;
	}
	
	private Response checkValidityOfInputIndex(String index, ArrayList<Entry> entries) {
		int indexValue = Integer.valueOf(index);
		int maxEntryIndex = entries.size();
		Response responseForInputIndex = new Response();
		
		if (indexValue > maxEntryIndex || indexValue < MIN_ENTRY_INDEX) {
			setFailureResponseForInvalidIndex(responseForInputIndex);
			_logger.log(Level.INFO, "Generated failure response for invalid index");
		} else {
			responseForInputIndex.setIsSuccess(true);
		}
		
		return responseForInputIndex;
	}
	
	private void setFailureResponseForInvalidIndex(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_INVALID_INDEX);
	}
}
```
###### src\com\taskboard\main\Logic.java
``` java
package com.taskboard.main;

import com.taskboard.main.command.Command;

import com.taskboard.main.parser.CommandParser;

import com.taskboard.main.util.Response;

/**
 * This class receives the user input and processes it accordingly.
 * It then executes the corresponding command and returns a Response based
 * on the success of the operation.
 * @author Amarparkash Singh Mavi
 *
 */
public class Logic {
	
	// attribute
	
	private CommandParser _commandParser;
	
	// constructor
	
	public Logic() {
		_commandParser = new CommandParser();
	}
	
	// other functionalities
	
	/**
	 * This method processes the input by the user and executes the corresponding
	 * command. It returns a Response based on the success of the operation.
	 * 
	 * @param userInput Input string by the user.
	 * @return          Response.
	 */
	public Response processCommand(String userInput) {
		Response responseForOperations = new Response();
		
		try {
			Command commandInput = _commandParser.parseCommand(userInput);
			responseForOperations = commandInput.executeCommand();
		} catch (IllegalArgumentException ex) {
			responseForOperations.setIsSuccess(false);
			responseForOperations.setFeedback(ex.getMessage());
		}
		
		return responseForOperations; 
	}
}
```
###### src\com\taskboard\main\SelectiveFilter.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;

/**
 * This class contains the different filters and executes each of them when invoked. 
 * It returns the filtered entries as a result.
 * @author Amarparkash Singh Mavi
 *
 */
public class SelectiveFilter {
	
	// These are the time formats assigned for the respective entries to facilitate filtering by date only
	private static final String FORMAT_DEADLINE_TASK_DEFAULT_TIME_FOR_FILTER_BY_DATE = "00:00";
	private static final String FORMAT_EVENT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE = "00:00";
	private static final String FORMAT_EVENT_DEFAULT_END_TIME_FOR_FILTER_BY_DATE = "23:59";
	
	// attribute
	
	private Logger _logger;

	// constructor
	
	public SelectiveFilter() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/** 
	 * This method executes filtering of entries by entry name and returns the filtered entries.
	 * 
	 * @param entries   Entries used for the filtering
	 * @param searchKey Substring used to filter entries by entry name
	 * @return			Filtered entries 
	 */
	public ArrayList<Entry> filterByName(ArrayList<Entry> entries, String searchKey) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			String entryName = entry.getNameParameter().getParameterValue();
			
			// performing case-insensitive search
			if (entryName.toLowerCase().contains(searchKey.toLowerCase())) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by name: " + entryName);
			}
		}
		
		return filteredEntries;
	}
	
	/**
	 * This method executes filtering of entries by priority and returns the filtered entries.
	 * 
	 * @param entries		 Entries used for the filtering
	 * @param searchPriority Priority level used to filter entries by priority
	 * @return               Filtered Entries
	 */
	public ArrayList<Entry> filterByPriority(ArrayList<Entry> entries, String searchPriority) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter priorityParameter = entry.getPriorityParameter();
			
			if (priorityParameter != null) {
				String priority = priorityParameter.getParameterValue();
				if (priority.equals(searchPriority)) {
					filteredEntries.add(entry);
					_logger.log(Level.INFO, "Successfully filtered entry by priority: " 
					            + entry.getNameParameter().getParameterValue());
				}
			}
		} 
		
		return filteredEntries;
	}
	
	/**
	 * This method executes filtering of entries by category and returns the filtered entries.
	 * 
	 * @param entries        Entries used for the filtering
	 * @param searchCategory Category name used to filter entries by category
	 * @return				 Filtered Entries
	 */
	public ArrayList<Entry> filterByCategory(ArrayList<Entry> entries, String searchCategory) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter categoryParameter = entry.getCategoryParameter();
			
			if (categoryParameter != null) {
				String category = categoryParameter.getParameterValue();
				// performing case-insensitive search
				if (category.equalsIgnoreCase(searchCategory)) {
					filteredEntries.add(entry);
					_logger.log(Level.INFO, "Successfully filtered entry by category: " 
				                + entry.getNameParameter().getParameterValue());
				}
			}
		} 
		
		return filteredEntries;
	}
	
	/**
	 * This method executes filtering of entries by date only and returns the filtered entries.
	 *  
	 * @param entries   Entries used for the filtering
	 * @param inputDate Date used to filter entries by date
	 * @return			Filtered entries
	 */
	public ArrayList<Entry> filterByDate(ArrayList<Entry> entries, Date inputDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			
			boolean hasDeadlineDateMatched = false;
			boolean hasEventDateMatched = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
					        + entry.getNameParameter().getParameterValue());
				hasDeadlineDateMatched = hasDeadlineDateMatched(dateParameter, inputDate);
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
					        + entry.getNameParameter().getParameterValue());
			    hasEventDateMatched = hasEventDateMatched(startDateParameter, endDateParameter,  
					                                      inputDate); 		
			}
			
			if (hasDeadlineDateMatched || hasEventDateMatched) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date: " 
		                    + entry.getNameParameter().getParameterValue());
			}
		}
			
		return filteredEntries;
	}
		
	private boolean hasDeadlineDateMatched(Parameter dateParameter, Date referenceDate) {
		String date = dateParameter.getParameterValue();
		String time = FORMAT_DEADLINE_TASK_DEFAULT_TIME_FOR_FILTER_BY_DATE;
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		if (deadlineDate.equals(referenceDate)) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date");
			return true;
		}
	
		return false;
	}
	
	private Date retrieveDateFromDateTimeDetails(String date, String time) {
		DateTimeValidator dateTimeValidator = new DateTimeValidator();
		dateTimeValidator.validateDateTimeDetails(date, time, null);
		Date convertedDate = dateTimeValidator.getDate();
		
		return convertedDate;
	}
	
	private boolean hasEventDateMatched(Parameter startDateParameter, Parameter endDateParameter,
			                            Date referenceDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = FORMAT_EVENT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE;
		String endDate = endDateParameter.getParameterValue();
		String endTime = FORMAT_EVENT_DEFAULT_END_TIME_FOR_FILTER_BY_DATE;
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceDate);
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceDate);
		if (referenceDateIndicatorForEventStartDate <= 0 && referenceDateIndicatorForEventEndDate >= 0) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date");
			return true;
		}
		
		return false;
		
	}
	
	/**
	 * This method executes filtering of entries by date time and returns the filtered entries.
	 * 
	 * @param entries   Entries used for the filtering
	 * @param inputDate Date used to filter entries by date time
	 * @return			Filtered entries
	 */
	public ArrayList<Entry> filterByDateTime(ArrayList<Entry> entries, Date inputDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter timeParameter = entry.getTimeParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter startTimeParameter = entry.getStartTimeParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			Parameter endTimeParameter = entry.getEndTimeParameter();
			
			boolean hasDeadlineDateTimeMatched = false;
			boolean hasEventDateTimeMatched = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
						    + entry.getNameParameter().getParameterValue());
				hasDeadlineDateTimeMatched = hasDeadlineDateTimeMatched(dateParameter, timeParameter, 
						                                                inputDate); 
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
						    + entry.getNameParameter().getParameterValue());
				hasEventDateTimeMatched = hasEventDateTimeMatched(startDateParameter, startTimeParameter, 
						                                          endDateParameter, endTimeParameter, 
						                                          inputDate); 				                                         
			}
			
			if (hasDeadlineDateTimeMatched || hasEventDateTimeMatched) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date time: " 
		                    + entry.getNameParameter().getParameterValue());
			}
		}
		
		return filteredEntries;
	}
	
	private boolean hasDeadlineDateTimeMatched(Parameter dateParameter, Parameter timeParameter, 
			                                   Date referenceDate) {
		String date = dateParameter.getParameterValue();
		String time = "";	
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
		
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		if (deadlineDate.equals(referenceDate)) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date time");
			return true;
		}
	
		return false;
	}
				
	private boolean hasEventDateTimeMatched(Parameter startDateParameter, Parameter startTimeParameter,
			                                Parameter endDateParameter, Parameter endTimeParameter, 
			                                Date referenceDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		
		String endDate = endDateParameter.getParameterValue();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceDate);
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceDate);
		if (referenceDateIndicatorForEventStartDate <= 0 && referenceDateIndicatorForEventEndDate >= 0) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date time");
			return true;
		}
		
		return false;
	}
	
	/**
	 * This method executes filtering of entries by date time range and returns the filtered entries.
	 * 
	 * @param entries        Entries used for the filtering
	 * @param inputStartDate Start date of date time range
	 * @param inputEndDate   End date of date time range
	 * @return				 Filtered entries
	 */
	public ArrayList<Entry> filterByDateTimeRange(ArrayList<Entry> entries, Date inputStartDate, 
			                                      Date inputEndDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter timeParameter = entry.getTimeParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter startTimeParameter = entry.getStartTimeParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			Parameter endTimeParameter = entry.getEndTimeParameter();
			
			boolean isDeadlineDateTimeInRange = false;
			boolean isEventDateTimeInRange = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
					        + entry.getNameParameter().getParameterValue());
				isDeadlineDateTimeInRange = isDeadlineDateTimeInRange(dateParameter, timeParameter,  
						                                              inputStartDate, inputEndDate);
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
					        + entry.getNameParameter().getParameterValue());
				isEventDateTimeInRange = isEventDateTimeInRange(startDateParameter, startTimeParameter,  
				                                                endDateParameter, endTimeParameter,
				                                                inputStartDate,  inputEndDate);
			}
			
			if (isDeadlineDateTimeInRange || isEventDateTimeInRange) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date time range: " 
	                        + entry.getNameParameter().getParameterValue());
			}
		}
		
		return filteredEntries;
	}
		
	private boolean isDeadlineDateTimeInRange(Parameter dateParameter, Parameter timeParameter, 
			                                  Date referenceStartDate, Date referenceEndDate) {
		String date = dateParameter.getParameterValue();
		String time = "";
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
			
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		int referenceStartDateIndicator = deadlineDate.compareTo(referenceStartDate);
		int referenceEndDateIndicator = deadlineDate.compareTo(referenceEndDate);
		if (referenceStartDateIndicator >= 0 && referenceEndDateIndicator <= 0) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date time range");
			return true;
		}
	
		return false;
	}
	
	private boolean isEventDateTimeInRange(Parameter startDateParameter, Parameter startTimeParameter,
			                               Parameter endDateParameter, Parameter endTimeParameter, 
			                               Date referenceStartDate, Date referenceEndDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		
		String endDate = endDateParameter.getParameterValue();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceStartDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceStartDate);
		int referenceEndDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceEndDate);
		boolean isEventStartDateInSearchRange = referenceStartDateIndicatorForEventStartDate >= 0 && 
				                                referenceEndDateIndicatorForEventStartDate <= 0;
		
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceStartDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceStartDate);
		int referenceEndDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceEndDate);
		boolean isEventEndDateInSearchRange = referenceStartDateIndicatorForEventEndDate >= 0 && 
				                              referenceEndDateIndicatorForEventEndDate <= 0;
		
		boolean isSearchRangeInEventRange = referenceStartDateIndicatorForEventStartDate < 0 && 
			                            	referenceEndDateIndicatorForEventEndDate > 0;
		
		if (isEventStartDateInSearchRange || isEventEndDateInSearchRange || isSearchRangeInEventRange) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date time range");
			return true;
		}
		
		return false;
	}
}
```
###### src\com\taskboard\main\SelectiveFilterProcessor.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/**
 * This class determines the type of filtering required and processes it accordingly
 * to obtain the filtered entries. It returns a corresponding Response upon verification.
 * @author Amarparkash Singh Mavi
 *
 */
public class SelectiveFilterProcessor {
	
	// This is the feedback message to be displayed to the user
	private static final String MESSAGE_FILTER_RESULTS = "%1$s entries found based on search results!";
	
	// These are the time formats assigned for the respective filters, when the time detail is not provided
	private static final String FORMAT_DEFAULT_TIME_FOR_FILTER_BY_DATE = "00:00"; 
	private static final String FORMAT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE_TIME_RANGE = "00:00";
	
	// attributes
	
	/** This attribute is the ArrayList of entries filtered*/
	private ArrayList<Entry> _filteredEntries;
	
	private Logger _logger;
	
	// constructor
	
	public SelectiveFilterProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// accessor
	
	public ArrayList<Entry> getFilteredEntries() {
		return _filteredEntries;
	}
	
	// other functionalities
	
	/**
	 * This method determines the type of filtering required and processes it accordingly.
	 * It returns a corresponding Response upon verification.  
	 * 
	 * @param entries    ArrayList of entry objects which represents the current entries registered.
	 * @param parameters ArrayList of parameter objects which determine the type of filter
	 * @return			 Response
	 */
	public Response processFiltering(ArrayList<Entry> entries, ArrayList<Parameter> parameters) {
		_filteredEntries = entries;
		
		if (isFilterByName(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by name");
			_filteredEntries = processFilterByName(parameters);
		}
		
		if (isFilterByPriority(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by priority");
			_filteredEntries = processFilterByPriority(parameters);
		}
		
		if (isFilterByCategory(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by category");
			_filteredEntries = processFilterByCategory(parameters);
		}
		
		Response responseForFiltering = new Response();
		if (isFilterByDate(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date");
			DateTimeValidator dateValidator = new DateTimeValidator();
			responseForFiltering = checkForDateValidity(dateValidator, parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDate(dateValidator);
		}
		
		if (isFilterByDateTime(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date time");
			DateTimeValidator dateTimeValidator = new DateTimeValidator();
			responseForFiltering = checkForDateTimeValidity(dateTimeValidator, parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDateTime(dateTimeValidator); 
		}
		
		if (isFilterByDateTimeRange(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date time range");
			DateTimeValidator startDateTimeValidator = new DateTimeValidator();
			DateTimeValidator endDateTimeValidator = new DateTimeValidator();
			responseForFiltering = checkForDateTimeValidity(startDateTimeValidator, endDateTimeValidator,
					                                        parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDateTimeRange(startDateTimeValidator, 
					                                        endDateTimeValidator);
		}
		
		setSuccessResponseForViewWithFilter(responseForFiltering);
		
		return responseForFiltering;
	}
		
	private boolean isFilterByName(ArrayList<Parameter> parameters) {
		Parameter nameParameter = getNameParameter(parameters);
		if (nameParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getNameParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.NAME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByName(ArrayList<Parameter> parameters) {
		String searchKey = getDetailFromParameter(getNameParameter(parameters));
		SelectiveFilter selectiveFilterByName = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByName.filterByName(_filteredEntries, searchKey);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
		            + " entries by name");
		
		return filteredEntries;
	}
	
	private String getDetailFromParameter(Parameter parameter) {
		String detail = "";
		if (parameter != null) {
			detail = parameter.getParameterValue();
		}
		
		return detail;
	}
	
	private boolean isFilterByPriority(ArrayList<Parameter> parameters) {
		Parameter priorityParameter = getPriorityParameter(parameters);
		if (priorityParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getPriorityParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByPriority(ArrayList<Parameter> parameters) {
		String searchPriority = getDetailFromParameter(getPriorityParameter(parameters));
		SelectiveFilter selectiveFilterByPriority = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByPriority.filterByPriority(_filteredEntries, 
				                                                                      searchPriority);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by priority");
		
		return filteredEntries;
	}
	
	private boolean isFilterByCategory(ArrayList<Parameter> parameters) {
		Parameter categoryParameter = getCategoryParameter(parameters);
		if (categoryParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getCategoryParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByCategory(ArrayList<Parameter> parameters) {
		String searchCategory = getDetailFromParameter(getCategoryParameter(parameters));
		SelectiveFilter selectiveFilterByCategory = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByCategory.filterByCategory(_filteredEntries, 
				                                                                      searchCategory); 
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
        			+ " entries by category");
		
		return filteredEntries;
	}
	
	private boolean isFilterByDate(ArrayList<Parameter> parameters) {
		Parameter dateParameter = getDateParameter(parameters);
		Parameter timeParameter = getTimeParameter(parameters);
		if (dateParameter != null && timeParameter == null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Response checkForDateValidity(DateTimeValidator dateValidator, ArrayList<Parameter> parameters) {
		String date = getDetailFromParameter(getDateParameter(parameters));
		String time = FORMAT_DEFAULT_TIME_FOR_FILTER_BY_DATE; 
		_logger.log(Level.INFO, "Start validating date");
		Response responseForDate = dateValidator.validateDateTimeDetails(date, time, null);
		
		return responseForDate;
	}
	
	private ArrayList<Entry> processFilterByDate(DateTimeValidator dateValidator) {
		Date inputDate = dateValidator.getDate();
		SelectiveFilter selectiveFilterByDate = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDate.filterByDate(_filteredEntries, 
				                                                              inputDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date");

		return filteredEntries;
	}
		
	private boolean isFilterByDateTime(ArrayList<Parameter> parameters) {
		Parameter timeParameter = getTimeParameter(parameters);
		if (timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response checkForDateTimeValidity(DateTimeValidator dateTimeValidator, 
			                                  ArrayList<Parameter> parameters) { 
		String date = getDetailFromParameter(getDateParameter(parameters));
		String time = getDetailFromParameter(getTimeParameter(parameters));	
		
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details");
		Response responseForDateTime = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(date, time);
		
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Start validating date time details");
			responseForDateTime = dateTimeValidator.validateDateTimeDetails(date, time, null);
		}
		
		return responseForDateTime;
	}
	
	private ArrayList<Entry> processFilterByDateTime(DateTimeValidator dateTimeValidator) {
		Date inputDate = dateTimeValidator.getDate();
		SelectiveFilter selectiveFilterByDateTime = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDateTime.filterByDateTime(_filteredEntries, 
				                                                                      inputDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date time");
		
		return filteredEntries;
	}
		
	private boolean isFilterByDateTimeRange(ArrayList<Parameter> parameters) {
		Parameter startDateParameter = getStartDateParameter(parameters);
		Parameter startTimeParameter = getStartTimeParameter(parameters);
		Parameter endDateParameter = getEndDateParameter(parameters);
	    Parameter endTimeParameter = getEndTimeParameter(parameters);
		if (startDateParameter != null || startTimeParameter != null || endDateParameter != null || 
	        endTimeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getStartDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getStartTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getEndDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getEndTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Response checkForDateTimeValidity(DateTimeValidator startDateTimeValidator, 
			                                  DateTimeValidator endDateTimeValidator, 
			                                  ArrayList<Parameter> parameters) {
		String startDate = getDetailFromParameter(getStartDateParameter(parameters));
		String startTime = getDetailFromParameter(getStartTimeParameter(parameters));
		String endDate = getDetailFromParameter(getEndDateParameter(parameters));
		String endTime = getDetailFromParameter(getEndTimeParameter(parameters));
		if (startTime.isEmpty()) {
			startTime = FORMAT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE_TIME_RANGE; 
		}
		
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing range of date time details");
		Response responseForDateTime = eventDateTimeProcessor.processEventDateTimeDetails(startDate, startTime, 
				                                                                          endDate, endTime);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			endDate = startDate;
		}
		
		// This implies date time details are in accepted event format and can proceed for validation
		if (responseForDateTime.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating start date time details");
			responseForDateTime = startDateTimeValidator.validateDateTimeDetails(startDate, startTime, null);	
			if (responseForDateTime.getFeedback() == null) {
				Date inputStartDate = startDateTimeValidator.getDate();
				_logger.log(Level.INFO, "Start validating end date time details");
				responseForDateTime = endDateTimeValidator.validateDateTimeDetails(endDate, endTime, 
						                                                           inputStartDate);
			}
		}
		
		return responseForDateTime;
	}
		
	private ArrayList<Entry> processFilterByDateTimeRange(DateTimeValidator startDateTimeValidator,
			                                              DateTimeValidator endDateTimeValidator) {
		Date inputStartDate = startDateTimeValidator.getDate();
		Date inputEndDate = endDateTimeValidator.getDate();
		SelectiveFilter selectiveFilterByDateTimeRange = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDateTimeRange.filterByDateTimeRange(_filteredEntries, 
				                                                                                inputStartDate,
				                                                                                inputEndDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date time range");
		
		return filteredEntries;
	}
	
	private void setSuccessResponseForViewWithFilter(Response response) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulViewWithFilter();
		response.setFeedback(userFeedback);
		response.setEntries(_filteredEntries);
	}
	
	private String getFeedbackForSuccessfulViewWithFilter() {
		int numOfFilteredEntries = _filteredEntries.size();
		String feedback = String.format(MESSAGE_FILTER_RESULTS, numOfFilteredEntries);
		if (numOfFilteredEntries == 1) {
			feedback = feedback.replace("entries", "entry");
		}
		
		return feedback;
		
	}
}
```
###### src\com\taskboard\main\util\Response.java
``` java
package com.taskboard.main.util;

import java.util.ArrayList;

/**
 * This class is used as a container class comprising of a boolean denoting 
 * whether the operation is successful, a feedback String of the operation, and 
 * a collection of entries denoting the entries after the operation is done.
 * @author Alvian Prasetya
 */
public class Response {
	
	// attributes
	
	private boolean _isSuccess;
	private String _feedback;
	private ArrayList<Entry> _entries;
	
	// constructor
	
	public Response() {		
	
	}
	
	// accessors 
	
	public boolean isSuccess() {
		return _isSuccess;
	}
	
	public String getFeedback() {
		return _feedback;
	}
	
	public ArrayList<Entry> getEntries() {
		return _entries;
	}
	
	// mutators
	
	public void setIsSuccess(boolean isSuccess) {
		_isSuccess = isSuccess;	
	}
	
	public void setFeedback(String feedback) {
		_feedback = feedback;
	}
	
	public void setEntries(ArrayList<Entry> entries) {
		_entries = entries;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Response) {
			Response response = (Response) obj;
			
			boolean isEqual;
			if (this.isSuccess() == true) {
				isEqual = this._isSuccess == response._isSuccess && 
						  this._feedback.equals(response._feedback) &&
						  this.retrieveEntryDetails(this._entries).equals(response.retrieveEntryDetails(response._entries));
			} else {
				isEqual = this._isSuccess == response._isSuccess &&
						  this._feedback.equals(response._feedback);
			}
			
			return isEqual;
		}
		
		return false;
	}
	
	private String retrieveEntryDetails(ArrayList<Entry> entries) {
		String entryDetails = "";
		
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			entryDetails = entryDetails.concat(entry.toString());
		}
		
		return entryDetails;
	}
}
```
###### src\com\taskboard\test\LogicTest.java
``` java
package com.taskboard.test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.Before;
import org.junit.After;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.Collections;

import com.taskboard.main.Logic;

import com.taskboard.main.comparator.DateComparator;
import com.taskboard.main.comparator.ParameterComparator;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

/** This is an integration test class to test the integration of Logic with CommandParser
 * and the storage handler classes. It tests for the different types of responses returned
 * to UserInterface. Therefore, the test cases have been designed using Equivalence Partitioning
 * where each partition corresponds to a response for a specific scenario. The intent is to achieve
 * maximum decision/branch coverage.
 * @author Amarparkash Singh Mavi
 *
 */
public class LogicTest {
	
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_AFTER_ADD = "Entry successfully added:";
	private static final String MESSAGE_AFTER_EDIT = "Entry successfully updated:";
	private static final String MESSAGE_FOR_UPDATED_ENTRY = "Entry after update =>";
	private static final String MESSAGE_FOR_OLD_ENTRY = "Entry before update =>";
	private static final String MESSAGE_AFTER_COMPLETE = "Entry successfully indicated as completed:";
	private static final String MESSAGE_EMPTY_ARCHIVE = "There are no completed entries.";
	private static final String MESSAGE_RETRIEVE_ARCHIVE_SUCCESS = "Successfully retrieved all archived entries.";
	private static final String MESSAGE_AFTER_RESTORE = "Entry successfully restored:";
	private static final String MESSAGE_FILTER_RESULTS = "%1$s entries found based on search results!";
	private static final String MESSAGE_AFTER_DELETE = "Entry successfully deleted:";
	private static final String MESSAGE_ERROR_FOR_CREATING_EXISTNG_FILE = "The file already exists.";
	private static final String MESSAGE_ERROR_FOR_OPENING_NON_EXISTING_FILE = "The file does not exists.";
	private static final String MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND = "No parameters provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_PRI_PARAMETER = "Empty pri parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_BY_PARAMETER = "Empty by parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_CAT_PARAMETER = "Empty cat parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_FROM_PARAMETER = "Empty from parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_TO_PARAMETER = "Empty to parameter provided.";
	private static final String MESSAGE_ERROR_FOR_NO_VALID_DATE = "No valid date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_VALID_START_DATE = "No valid start date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_VALID_END_DATE_TIME = "No valid end date time provided.";
	private static final String MESSAGE_ERROR_FOR_PAST_DATE_TIME = "Past date time provided.";
	private static final String MESSAGE_ERROR_FOR_NO_EDITED_DETAILS = "No edited details provided.";
	private static final String MESSAGE_ERROR_FOR_INVALID_INDEX_FORMAT = "Invalid numeric format provided for index.";
	private static final String MESSAGE_ERROR_FOR_INVALID_INDEX = "Invalid index provided.";
	
	private File testStorageFileForNew;
	private File testArchiveFileForNew;
	private File testPreferenceFileForNew;
	private File testStorageFileForOpen;
	private File testArchiveFileForOpen;
	private File testPreferenceFileForOpen;
	private ArrayList<Entry> expectedEntries; 
	private Logic logic;
	
	@Before 
	public void setUp() throws IOException {
		logic = new Logic();
		
		testStorageFileForNew = new File("testNew" + ".str");
		testStorageFileForNew.createNewFile();
		testArchiveFileForNew = new File("testNew" + ".arc");
		testArchiveFileForNew.createNewFile();
		testPreferenceFileForNew = new File("testNew" + ".pref");
		testPreferenceFileForNew.createNewFile();
		
		testStorageFileForOpen = new File("testOpen" + ".str");
		testStorageFileForOpen.createNewFile();
		testArchiveFileForOpen = new File("testOpen" + ".arc");
		testArchiveFileForOpen.createNewFile();
		testPreferenceFileForOpen = new File("testOpen" + ".pref");
		testPreferenceFileForOpen.createNewFile();
		
		Entry event1 = new Entry();
		event1.addToParameters(new Parameter(ParameterType.INDEX, "1"));
		event1.addToParameters(new Parameter(ParameterType.NAME, "Quaterly Meeting"));
		event1.addToParameters(new Parameter(ParameterType.START_DATE, "03/03/2016"));
		event1.addToParameters(new Parameter(ParameterType.START_TIME, "10:00"));
		event1.addToParameters(new Parameter(ParameterType.END_DATE, "03/03/2016"));
		event1.addToParameters(new Parameter(ParameterType.END_TIME, "11:30"));
		event1.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event1.addToParameters(new Parameter(ParameterType.CATEGORY, "Finance"));
		expectedEntries = new ArrayList<Entry>();
		expectedEntries.add(event1);
		
		Entry event2 = new Entry();
		event2.addToParameters(new Parameter(ParameterType.INDEX, "2"));
		event2.addToParameters(new Parameter(ParameterType.NAME, "Annual Meeting"));
		event2.addToParameters(new Parameter(ParameterType.START_DATE, "14/04/2016"));
		event2.addToParameters(new Parameter(ParameterType.START_TIME, "09:00"));
		event2.addToParameters(new Parameter(ParameterType.END_DATE, "14/04/2016"));
		event2.addToParameters(new Parameter(ParameterType.END_TIME, "11:00"));
		event2.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event2.addToParameters(new Parameter(ParameterType.CATEGORY, "Marketing"));
		expectedEntries.add(event2);
		
		Entry deadlineTask1 = new Entry();
		deadlineTask1.addToParameters(new Parameter(ParameterType.INDEX, "3"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.NAME, "Complete annual feedback survey"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.DATE, "25/04/2016"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.TIME, "14:00"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.PRIORITY, "low"));
		expectedEntries.add(deadlineTask1);
		
		Entry deadlineTask2 = new Entry();
		deadlineTask2.addToParameters(new Parameter(ParameterType.INDEX, "4"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.NAME, "Annual company dinner"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.DATE, "02/05/2016"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.TIME, "18:00"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.CATEGORY, "Functions"));
		expectedEntries.add(deadlineTask2);
		
		FileWriter addToFile = new FileWriter(testStorageFileForOpen);
		for (int i = 0; i < expectedEntries.size(); i++) {
			String entrydetails = expectedEntries.get(i).toString();
			addToFile.write(entrydetails);
			addToFile.write(System.lineSeparator());
			addToFile.flush();
		}
		addToFile.close();
		
		logic.processCommand("open testOpen");
	}
		
	@Test
	public void testResponsesForNew() {
		Response actualResponse = logic.processCommand("new testNew");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_CREATING_EXISTNG_FILE);
		testResponseEquality("failure Response partition for creating file that already exists", 
				              expectedResponse, actualResponse);
			
		actualResponse = logic.processCommand("new AcademicManager");		
		ArrayList<Entry> expectedEntriesForNew = new ArrayList<Entry>();
		String feedback = getFeedbackForSuccessfulLaunch("AcademicManager");
		expectedResponse = createSuccessResponse(feedback, expectedEntriesForNew);
		testResponseEquality("success response partition for creating new file", expectedResponse, 
				              actualResponse);
		File storageFile = new File("AcademicManager" + ".str");
		storageFile.delete();
		File archiveFile = new File("AcademicManager" + ".arc");
		archiveFile.delete();
		File preferenceFile = new File("AcademicManager" + ".pref");
		preferenceFile.delete();
		
		logic.processCommand("open testOpen");
	}
	
	private String getFeedbackForSuccessfulLaunch(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	@Test
	public void testResponsesForOpen() {
		Response actualResponse = logic.processCommand("open TaskManager");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_OPENING_NON_EXISTING_FILE);
		testResponseEquality("failure response partition for opening file that does not exists", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("open testOpen");
		String feedback = getFeedbackForSuccessfulLaunch("testOpen");
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for opening existing file", expectedResponse, 
				              actualResponse);
	}
	
	@Test
	public void testResponsesForAdd() { 
		Response actualResponse = logic.processCommand("add ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("failure response partition for not providing parameters after add command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("a Prepare for EE2020 Final Quiz pri ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_PRI_PARAMETER);
		testResponseEquality("failure response partition for providing empty pri parameter", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("a Prepare for EE2020 Final Quiz pri H");
		Entry floatingTask = new Entry();
		floatingTask.addToParameters(new Parameter(ParameterType.INDEX, ""));
		floatingTask.addToParameters(new Parameter(ParameterType.NAME, "Prepare for EE2020 Final Quiz"));
		floatingTask.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		expectedEntries.add(floatingTask);
		updateSortingOfEntries(expectedEntries);
		String feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_ADD, floatingTask);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		// testing multiple inputs
		testResponseEquality("success response partition for adding floating task with priority", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_BY_PARAMETER);
		testResponseEquality("failure response partition for providing empty by parameter", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by 10am");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_VALID_DATE);
		testResponseEquality("failure response partition for not providing date", expectedResponse, 
				              actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by 03/11/2015 10am");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
		testResponseEquality("failure response partition for providing past date time", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by fri 10am cat ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_CAT_PARAMETER);
		testResponseEquality("failure response partition for providing empty cat parameter", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit HW2 by 3 Sep 2016 10am cat MA3264");
		Entry deadlineTask = new Entry();
		deadlineTask.addToParameters(new Parameter(ParameterType.INDEX, ""));
		deadlineTask.addToParameters(new Parameter(ParameterType.NAME, "Submit HW2"));
		deadlineTask.addToParameters(new Parameter(ParameterType.DATE, "03/09/2016"));
		deadlineTask.addToParameters(new Parameter(ParameterType.TIME, "10:00"));
		deadlineTask.addToParameters(new Parameter(ParameterType.CATEGORY, "MA3264"));
		expectedEntries.add(deadlineTask);
		updateSortingOfEntries(expectedEntries);
		feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_ADD, deadlineTask);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		// testing multiple inputs
		testResponseEquality("success response partition for adding deadline task with category", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_FROM_PARAMETER);
		testResponseEquality("failure response partition for providing empty from parameter", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_VALID_END_DATE_TIME);
		testResponseEquality("failure response partition for not providing end date time", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm to");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_TO_PARAMETER);
		testResponseEquality("failure response partition for providing empty to parameter", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 1pm to 3pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_VALID_START_DATE);
		testResponseEquality("failure response partition for not providing start date", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm to 12pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
		testResponseEquality("failure response partition for providing end date time earlier than "
				              + "start date time", expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27 Nov 2016 1pm to 3pm pri H cat MA3264");
		Entry event = new Entry();
		event.addToParameters(new Parameter(ParameterType.INDEX, ""));
		event.addToParameters(new Parameter(ParameterType.NAME, "Final Exam"));
		event.addToParameters(new Parameter(ParameterType.START_DATE, "27/11/2016"));
		event.addToParameters(new Parameter(ParameterType.START_TIME, "13:00"));
		event.addToParameters(new Parameter(ParameterType.END_DATE, "27/11/2016"));
		event.addToParameters(new Parameter(ParameterType.END_TIME, "15:00"));
		event.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event.addToParameters(new Parameter(ParameterType.CATEGORY, "MA3264"));
		expectedEntries.add(event);
		updateSortingOfEntries(expectedEntries);
		feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_ADD, event);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		// testing multiple inputs
		testResponseEquality("success response partition for adding event with priority and category", 
			                 expectedResponse, actualResponse);
	}
	
	private void updateSortingOfEntries(ArrayList<Entry> entries) {
		Collections.sort(entries, new DateComparator());
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter indexParameter = new Parameter(ParameterType.INDEX, String.valueOf(i+1));
			entry.setIndexParameter(indexParameter);
		}
	}
	
	private String getSuccessFeedbackForSingleEntryDetails(String message, Entry entry) {
		String feedback = message.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	@Test
	public void testResponsesForEdit() {
		Response actualResponse = logic.processCommand("edit ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("failure response partition for not providing parameters after edit command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit Annual company dinner at Marina Mandarin");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX_FORMAT);
		testResponseEquality("failure response partition for providing invalid index format with edit", 
	                         expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit 4");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_EDITED_DETAILS);
		testResponseEquality("failure response partition for not providing edited details", 
	                         expectedResponse, actualResponse);
	
		actualResponse = logic.processCommand("edit 14 Annual company dinner at Marina Mandarin");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX);
		testResponseEquality("failure response partition for providing invalid index with edit", 
				              expectedResponse, actualResponse);	
	
		actualResponse = logic.processCommand("edit 4 Annual company dinner at Marina Mandarin");
		Entry entryToBeEdited1 = expectedEntries.get(3);
		Entry entryBeforeUpdate1 = new Entry(entryToBeEdited1);
		ArrayList<Parameter> entryDetails1 = entryToBeEdited1.getParameters();
		for (int i = 0; i < entryDetails1.size(); i++) {
			if (entryDetails1.get(i).getParameterType() == ParameterType.NAME) {
				entryDetails1.get(i).setParameterValue("Annual company dinner at Marina Mandarin");
			}
		}
		entryToBeEdited1.setParameters(entryDetails1);
		Entry entryAfterUpdate1 = new Entry(entryToBeEdited1);
		expectedEntries.set(3, entryToBeEdited1);
		updateSortingOfEntries(expectedEntries);
		String feedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate1, entryAfterUpdate1);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for editing entry name", expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit 3 cat Administrative pri m by 4pm");
		Entry entryToBeEdited2 = expectedEntries.get(2);
		Entry entryBeforeUpdate2 = new Entry(entryToBeEdited2);
		ArrayList<Parameter> entryDetails2 = entryToBeEdited2.getParameters();
		for (int i = 0; i < entryDetails2.size(); i++) {
			if (entryDetails2.get(i).getParameterType() == ParameterType.PRIORITY) {
				entryDetails2.get(i).setParameterValue("medium");
			}
			
			if (entryDetails2.get(i).getParameterType() == ParameterType.TIME) {
				entryDetails2.get(i).setParameterValue("16:00");
			}
		}
		entryDetails2.add(new Parameter(ParameterType.CATEGORY, "Administrative"));
		Collections.sort(entryDetails2, new ParameterComparator());
		entryToBeEdited2.setParameters(entryDetails2);
		Entry entryAfterUpdate2 = new Entry(entryToBeEdited2);
		expectedEntries.set(2, entryToBeEdited2);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate2, entryAfterUpdate2);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		// testing multiple inputs
		testResponseEquality("success response partition for editing multiple parameters of entry", 
			 	              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit 4 from 2 May 2016 6pm to 9pm");
		Entry entryToBeEdited3 = expectedEntries.get(3);
		Entry entryBeforeUpdate3 = new Entry(entryToBeEdited3);
		ArrayList<Parameter> entryDetails3 = entryToBeEdited3.getParameters();
		ArrayList<Parameter> newEntryDetails = new ArrayList<Parameter>();
		for (int i = 0; i < entryDetails3.size(); i++) {
			if (entryDetails3.get(i).getParameterType() == ParameterType.INDEX) {
				newEntryDetails.add(entryDetails3.get(i));
			}
			
			if (entryDetails3.get(i).getParameterType() == ParameterType.NAME) {
				newEntryDetails.add(entryDetails3.get(i));
			}
				
			if (entryDetails3.get(i).getParameterType() == ParameterType.CATEGORY) {
				newEntryDetails.add(entryDetails3.get(i));
			}
		}
		newEntryDetails.add(new Parameter(ParameterType.START_DATE, "02/05/2016"));
		newEntryDetails.add(new Parameter(ParameterType.START_TIME, "18:00"));
		newEntryDetails.add(new Parameter(ParameterType.END_DATE, "02/05/2016"));
		newEntryDetails.add(new Parameter(ParameterType.END_TIME, "21:00"));
		Collections.sort(newEntryDetails, new ParameterComparator());
		entryToBeEdited3.setParameters(newEntryDetails);
		Entry entryAfterUpdate3 = new Entry(entryToBeEdited3);
		expectedEntries.set(3, entryToBeEdited3);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate3, entryAfterUpdate3);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for changing entry type from deadline task to event", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit 1 at 10:30 4 Mar 2016");
		Entry entryToBeEdited4 = expectedEntries.get(0);
		Entry entryBeforeUpdate4 = new Entry(entryToBeEdited4);
		ArrayList<Parameter> entryDetails4 = entryToBeEdited4.getParameters();
		ArrayList<Parameter> newEntryDetails2 = new ArrayList<Parameter>();
		for (int i = 0; i < entryDetails4.size(); i++) {
			if (entryDetails4.get(i).getParameterType() == ParameterType.INDEX) {
				newEntryDetails2.add(entryDetails4.get(i));
			}
			
			if (entryDetails4.get(i).getParameterType() == ParameterType.NAME) {
				newEntryDetails2.add(entryDetails4.get(i));
			}
			
			if (entryDetails4.get(i).getParameterType() == ParameterType.PRIORITY) {
				newEntryDetails2.add(entryDetails4.get(i));
			}
				
			if (entryDetails4.get(i).getParameterType() == ParameterType.CATEGORY) {
				newEntryDetails2.add(entryDetails4.get(i));
			}
		}
		newEntryDetails2.add(new Parameter(ParameterType.DATE, "04/03/2016"));
		newEntryDetails2.add(new Parameter(ParameterType.TIME, "10:30"));
		Collections.sort(newEntryDetails2, new ParameterComparator());
		entryToBeEdited4.setParameters(newEntryDetails2);
		Entry entryAfterUpdate4 = new Entry(entryToBeEdited4);
		expectedEntries.set(0, entryToBeEdited4);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate4, entryAfterUpdate4);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for changing entry type from event to deadline task", 
				             expectedResponse, actualResponse);
	}
	
	private String getFeedbackForSuccessfulEdit(Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		String feedback = MESSAGE_AFTER_EDIT.concat("<br>").concat("<br>").concat(MESSAGE_FOR_UPDATED_ENTRY);
		feedback = feedback.concat("<br>").concat(entryAfterUpdate.toHTMLString());
		feedback = feedback.concat("<br>").concat(MESSAGE_FOR_OLD_ENTRY);
		feedback = feedback.concat("<br>").concat(entryBeforeUpdate.toHTMLString());
		
		return feedback;
	}
	
	@Test
	public void testResponsesForCompletionAndArchive() {
		Response actualResponse = logic.processCommand("complete ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("failure response partition for not providing parameters after complete command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("archive");
		ArrayList<Entry> completedEntries = new ArrayList<Entry>();
		expectedResponse = createSuccessResponse(MESSAGE_EMPTY_ARCHIVE, completedEntries);
		testResponseEquality("success response partition for empty archive", expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("complete Annual Meeting");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX_FORMAT);
		testResponseEquality("failure response partition for providing invalid index format with complete", 
	                         expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("complete 12");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX);
		testResponseEquality("failure response partition for providing invalid index with complete", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("complete 2");
		Entry entryCompleted = expectedEntries.remove(1);
		updateSortingOfEntries(expectedEntries);
		String feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_COMPLETE, entryCompleted);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for completing entry", expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("archive");		
		ArrayList<Parameter> entryDetails = entryCompleted.getParameters();
		for (int i = 0; i < entryDetails.size(); i++) {
			if (entryDetails.get(i).getParameterType() == ParameterType.INDEX) {
				entryDetails.get(i).setParameterValue("1");
			}
		}
		entryCompleted.setParameters(entryDetails);
		completedEntries.add(entryCompleted);
		expectedResponse = createSuccessResponse(MESSAGE_RETRIEVE_ARCHIVE_SUCCESS, completedEntries);
		testResponseEquality("success response partition for retrieving completed entries from archive", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("restore Annual Meeting");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX_FORMAT);
		testResponseEquality("failure response partition for providing invalid index format with restore", 
	                         expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("restore 2");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX);
		testResponseEquality("failure response partition for providing invalid index with restore", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("restore 1");
		Entry entryRestored = new Entry(entryCompleted);
		expectedEntries.add(entryCompleted);
		updateSortingOfEntries(expectedEntries);
		feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_RESTORE, entryRestored);
		completedEntries.clear();
		expectedResponse = createSuccessResponse(feedback, completedEntries);
		testResponseEquality("success response partition for restoring completed entry", expectedResponse, 
				              actualResponse);
	}
	
	@Test
	public void testResponsesForView() {
		Response actualResponse = logic.processCommand("view meeting");
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		filteredEntries.add(expectedEntries.get(0));
		filteredEntries.add(expectedEntries.get(1));
		String feedback = String.format(MESSAGE_FILTER_RESULTS, filteredEntries.size());
		Response expectedResponse = createSuccessResponse(feedback, filteredEntries);
		testResponseEquality("success response partition for filtering entries based on substring of entry names", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("view pri low");
		filteredEntries.clear();
		filteredEntries.add(expectedEntries.get(2));
		feedback = String.format(MESSAGE_FILTER_RESULTS, filteredEntries.size());
		feedback = feedback.replace("entries", "entry");
		expectedResponse = createSuccessResponse(feedback, filteredEntries);
		testResponseEquality("success response partition for filter results with only 1 entry", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("view from 3 Mar 2016 to 14 Apr 2016 pri H cat marketing");
		filteredEntries.clear();
		filteredEntries.add(expectedEntries.get(1));
		feedback = String.format(MESSAGE_FILTER_RESULTS, filteredEntries.size());
		feedback = feedback.replace("entries", "entry");
		expectedResponse = createSuccessResponse(feedback, filteredEntries);
		// testing multiple inputs
		testResponseEquality("success response partition for filtering entries using multiple filters", 
				             expectedResponse, actualResponse);
	}
	
	@Test
	public void testResponsesForDelete() {
		Response actualResponse = logic.processCommand("delete ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("failure response partition for not providing parameters after delete command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("delete Annual company dinner");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX_FORMAT);
		testResponseEquality("failure response partition for providing invalid index format with delete", 
	                         expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("delete 10");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX);
		testResponseEquality("failure response partition for providing invalid index with delete", 
				              expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("delete 4");
		Entry entryDeleted = expectedEntries.remove(3);
		updateSortingOfEntries(expectedEntries);
		String feedback = getSuccessFeedbackForSingleEntryDetails(MESSAGE_AFTER_DELETE, entryDeleted);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for deleting entry by index", expectedResponse, 
				             actualResponse);
		
		
		actualResponse = logic.processCommand("delete pri H");
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		filteredEntries.add(expectedEntries.get(0));
		filteredEntries.add(expectedEntries.get(1));
		expectedEntries.remove(1);
		expectedEntries.remove(0);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulDeleteByFiltering(filteredEntries); 
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("success response partition for deleting multiple entries using filter", 
				             expectedResponse, actualResponse);
	}
	
	private String getFeedbackForSuccessfulDeleteByFiltering(ArrayList<Entry> filteredEntries) {
		String feedback = String.format(MESSAGE_FILTER_RESULTS, filteredEntries.size());
		feedback = feedback.replace("found", "deleted");
		feedback = feedback.replace(".", ":");
		feedback = feedback.concat("<br>");
		for (int i = 0; i < filteredEntries.size(); i++) {
			Entry entry = filteredEntries.get(i);
			feedback = feedback.concat("<br>").concat(entry.toHTMLString());
		}
		
		return feedback;
	}
	
	private Response createSuccessResponse(String feedback, ArrayList<Entry> entries) {
		Response response = new Response();
		response.setIsSuccess(true);
		response.setFeedback(feedback);
		response.setEntries(entries);
		
		return response;
	}
	
	private Response createFailureResponse(String exMsg) {
		Response response = new Response();
		response.setIsSuccess(false);
		response.setFeedback(exMsg);
		
		return response;
	}
	
	private void testResponseEquality(String description, Response expectedResponse, Response actualResponse) {
		assertEquals(description, expectedResponse, actualResponse);
	}
	
	@After
	public void terminate() {
		testStorageFileForNew.delete();
		testArchiveFileForNew.delete();
		testPreferenceFileForNew.delete();
		testStorageFileForOpen.delete();
		testArchiveFileForOpen.delete();
		testPreferenceFileForOpen.delete();
	}
}
```
