# A0123935E
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\AddCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.DateTimeProcessor;
import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public class AddCommand extends Command {
	
	private static final String MESSAGE_AFTER_ADD = "Entry successfully added:";
	private static final String MESSAGE_ERROR_FOR_ADD = "The entry could not be added to the file.";

	public AddCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of AddCommand");
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		Response responseForAdd = new Response();
		if (isAddFloatingTask()) {
			_logger.log(Level.INFO, "Start process of adding floating task");
			responseForAdd = addFloatingTask();
		} else if (isAddDeadlineTask()) {
			_logger.log(Level.INFO, "Start process of adding deadline task");
			responseForAdd = addDeadlineTask();
		} else if (isAddEvent()) {
			_logger.log(Level.INFO, "Start process of adding event");
			responseForAdd = addEvent();
		}
		
		if (responseForAdd.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForAdd;
	}
	
	private boolean isAddFloatingTask() {
		if(!isAddDeadlineTask() && !isAddEvent()) {
			return true;
		}
		
		return false;
	}
	
	private boolean isAddDeadlineTask() {
		Parameter dateParameter = getDateParameter();
		Parameter timeParameter = getTimeParameter();
		if (dateParameter != null || timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private boolean isAddEvent() {
		Parameter startDateParameter = getStartDateParameter();
		Parameter startTimeParameter = getStartTimeParameter();
		if (startDateParameter != null || startTimeParameter != null) {
			return true;
		}
		
		return false;
	}
		
	private Response addFloatingTask() {
		String taskName = getDetailFromParameter(getNameParameter());
		assert !taskName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of floating task: " + taskName);
		
		String priority = getDetailFromParameter(getPriorityParameter());
		String category = getDetailFromParameter(getCategoryParameter());
		Response responseForAddFloating = processFloatingTaskForStorage(taskName, priority, category);
		
		return responseForAddFloating;
	}
	
	private Response processFloatingTaskForStorage(String taskName, String priority, String category) {
		Entry floatingTask = constructFloatingTaskParameters(taskName, priority, category);
		_logger.log(Level.INFO, "Successfully created floating task");
		Response responseForAddFloating = updateNewEntryToStorage(floatingTask);
			
		return responseForAddFloating;
	}
		
	private Entry constructFloatingTaskParameters(String taskName, String priority, String category) {
		Entry floatingTask = new Entry();
		addParameterToEntry(floatingTask, ParameterType.INDEX, "");
		addParameterToEntry(floatingTask, ParameterType.NAME, taskName);
		addParameterToEntry(floatingTask, ParameterType.PRIORITY, priority);
		addParameterToEntry(floatingTask, ParameterType.CATEGORY, category);
		
		return floatingTask;
	}
	
	private void addParameterToEntry(Entry entry, ParameterType parameterType, String detail) {
		if (parameterType == ParameterType.INDEX || !detail.isEmpty()) {
			Parameter parameter = new Parameter(parameterType, detail);
			entry.addToParameters(parameter);
		}
	}
	
	private Response updateNewEntryToStorage(Entry entry) {
		Response responseForAdd = new Response();
		try {
			_tempStorageManipulator.addToTempStorage(entry);
			setSuccessResponseForAdd(responseForAdd, entry);
			_logger.log(Level.INFO, "Generated success response for adding entry");
		} catch (IOException ex) {
			setFailureResponseForAdd(responseForAdd);
			_logger.log(Level.INFO, "Generated failure response for adding entry");
		}
		
		return responseForAdd;
	}
	
	private void setSuccessResponseForAdd(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackforSuccessfulAdd(entry);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackforSuccessfulAdd(Entry entry) {
		String feedback = MESSAGE_AFTER_ADD.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForAdd(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_ADD);
	}
			
	private Response addDeadlineTask() {
		String taskName = getDetailFromParameter(getNameParameter());
		assert !taskName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of deadline task: " + taskName);
		
		String date = getDetailFromParameter(getDateParameter());
		String time = getDetailFromParameter(getTimeParameter());
		String priority = getDetailFromParameter(getPriorityParameter());
		String category = getDetailFromParameter(getCategoryParameter());
		
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details for deadline task");
		Response responseForAddDeadline = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(date, time);
		if (responseForAddDeadline.isSuccess()) {
			_logger.log(Level.INFO, "Start validating date time details for deadline task");
			responseForAddDeadline = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(date, time);
			if (responseForAddDeadline.isSuccess()) {
				_logger.log(Level.INFO, "Start processing deadline task for storage");
				responseForAddDeadline = processDeadlineTaskForStorage(taskName, date, time, priority, category);  	                                               
			}
		}

		return responseForAddDeadline;
	}
	
	private Response processDeadlineTaskForStorage(String taskName, String date, String time,  
			                                       String priority, String category) {
		Entry deadlineTask = constructDeadlineTaskParameters(taskName, date, time, priority, category);
		_logger.log(Level.INFO, "Successfully created deadline task");
		Response responseForAddDeadline = updateNewEntryToStorage(deadlineTask);
		
		return responseForAddDeadline;
	}
	
	private Entry constructDeadlineTaskParameters(String taskName, String date, String time, 
			                                      String priority, String category) {
		Entry deadlineTask = new Entry();
		addParameterToEntry(deadlineTask, ParameterType.INDEX, "");
		addParameterToEntry(deadlineTask, ParameterType.NAME, taskName);
		addParameterToEntry(deadlineTask, ParameterType.DATE, date);
		addParameterToEntry(deadlineTask, ParameterType.TIME, time);
		addParameterToEntry(deadlineTask, ParameterType.PRIORITY, priority);
		addParameterToEntry(deadlineTask, ParameterType.CATEGORY, category);
	
		return deadlineTask;
	}
		
	private Response addEvent() {
		String eventName = getDetailFromParameter(getNameParameter());
		assert !eventName.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved name of event: " + eventName);
		
		String startDate = getDetailFromParameter(getStartDateParameter());
		String startTime = getDetailFromParameter(getStartTimeParameter());
		String endDate = getDetailFromParameter(getEndDateParameter());
		String endTime = getDetailFromParameter(getEndTimeParameter());
		String priority = getDetailFromParameter(getPriorityParameter());
		String category = getDetailFromParameter(getCategoryParameter());
		
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details for event");
		Response responseForAddEvent = eventDateTimeProcessor.processEventDateTimeDetails(startDate, startTime, 
				                                                                          endDate, endTime);
		if (responseForAddEvent.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			endDate = startDate;
		}
		if (responseForAddEvent.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating date time details for event");
			responseForAddEvent = eventDateTimeProcessor.validateEventDateTimeDetails(startDate, startTime, 
					                                                                  endDate, endTime);	
			if (responseForAddEvent.isSuccess()) {
				_logger.log(Level.INFO, "Start processing event for storage");
				responseForAddEvent = processEventForStorage(eventName, startDate, startTime, endDate, 
						                                     endTime, priority, category);
			}
		}

		return responseForAddEvent;
	}
		
	private Response processEventForStorage(String eventName, String startDate, String startTime,  
			                                String endDate, String endTime, String priority, String category) {
		Entry event = constructEventParameters(eventName, startDate, startTime, endDate, endTime,  
				                               priority, category);
		_logger.log(Level.INFO, "Successfully created event");
		Response responseForEvent = updateNewEntryToStorage(event);
		
		return responseForEvent;
	}
	
	private Entry constructEventParameters(String eventName, String startDate, String startTime, String endDate,
                                           String endTime, String priority, String category) {
		Entry event = new Entry();
		addParameterToEntry(event, ParameterType.INDEX, "");
		addParameterToEntry(event, ParameterType.NAME, eventName);
		addParameterToEntry(event, ParameterType.START_DATE, startDate);
		addParameterToEntry(event, ParameterType.START_TIME, startTime);
		addParameterToEntry(event, ParameterType.END_DATE, endDate);
		addParameterToEntry(event, ParameterType.END_TIME, endTime);
		addParameterToEntry(event, ParameterType.PRIORITY, priority);
		addParameterToEntry(event, ParameterType.CATEGORY, category);
		
		return event;
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\ArchiveCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class ArchiveCommand extends Command {
	
	private static final String MESSAGE_AFTER_ARCHIVE = "Successfully retrieved all archived entries.";  

	public ArchiveCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForArchive = new Response();
		responseForArchive.setIsSuccess(true);
		responseForArchive.setFeedback(MESSAGE_AFTER_ARCHIVE);
		responseForArchive.setEntries(_tempStorageManipulator.getTempArchive());
		_logger.log(Level.INFO, "Generated success response for accessing archive");
		
		return responseForArchive;
	}	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\Command.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Logger;

import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public abstract class Command {
	
	// attributes
	
	protected static TempStorageManipulator _tempStorageManipulator;
	protected ArrayList<Parameter> _parameters;
	protected Logger _logger;
	
	// accessors
		
	public ArrayList<Parameter> getParameters() {
		return _parameters;
	}
	
	public TempStorageManipulator getTempStorageManipulator() {
		return _tempStorageManipulator;
	}
	
	public Parameter getNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getNewNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NEW_NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getPriorityParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getCategoryParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	// mutators
	
	public void setParameters(ArrayList<Parameter> newParameters) {
		_parameters = newParameters;
	}
		
	public void setNameParameter(Parameter newNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				_parameters.set(i, newNameParameter);
			}
		}
	}
	
	public void setIndexParameter(Parameter newIndexParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.set(i, newIndexParameter);
			}
		}
	}
	
	
	public void setNewNameParameter(Parameter newNewNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NEW_NAME) {
				_parameters.set(i, newNewNameParameter);
			}
		}
	}
	
	public void setDateParameter(Parameter newDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				_parameters.set(i, newDateParameter);
			}
		}
	}
	
	public void setTimeParameter(Parameter newTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				_parameters.set(i, newTimeParameter);
			}
		}
	}
	
	public void setStartDateParameter(Parameter newStartDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				_parameters.set(i, newStartDateParameter);
			}
		}
	}
	
	public void setStartTimeParameter(Parameter newStartTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				_parameters.set(i, newStartTimeParameter);
			}
		}
	}
	
	public void setEndDateParameter(Parameter newEndDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				_parameters.set(i, newEndDateParameter);
			}
		}
	}
	
	public void setEndTimeParameter(Parameter newEndTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				_parameters.set(i, newEndTimeParameter);
			}
		}
	}
	
	public void setCategoryParameter(Parameter newCategoryParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				_parameters.set(i, newCategoryParameter);
			}
		}
	}
	
	public void setPriorityParameter(Parameter newPriorityParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				_parameters.set(i, newPriorityParameter);
			}
		}
	}

	public String getDetailFromParameter(Parameter parameter) {
		String detail = "";
		if (parameter != null) {
			detail = parameter.getParameterValue();
		}
		
		return detail;
	}
			
	public abstract Response executeCommand(); 	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\CompleteCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class CompleteCommand extends Command {
	
	private static final String MESSAGE_AFTER_COMPLETE = "Entry successfully indicated as completed:";
	private static final String MESSAGE_ERROR_FOR_COMPLETE = "The entry could not be indicated as completed.";
	
	public CompleteCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of CompleteCommand");
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		IndexProcessor indexProcessorForComplete = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForComplete = indexProcessorForComplete.processInputIndex(_parameters, entries);
		if (responseForComplete.isSuccess()) {
			_logger.log(Level.INFO, "Start process of indicating entry completion");
			responseForComplete = processEntryCompletion();
		}
				
		if (responseForComplete.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForComplete;
	}
		
	private Response processEntryCompletion() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempStorageIndex = indexValue - 1;
		Response responseForComplete = new Response();
		try {
			Entry entryToComplete = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			_tempStorageManipulator.setCompletedInTempStorage(tempStorageIndex);
			setSuccessResponseForComplete(responseForComplete, entryToComplete);
			_logger.log(Level.INFO, "Generated success response for indicating entry completion");
		} catch (IOException ex) {
			setFailureResponseForComplete(responseForComplete);
			_logger.log(Level.INFO, "Generated failure response for indicating entry completion");
		}
		
		return responseForComplete;
	}
	
	private void setSuccessResponseForComplete(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = MESSAGE_AFTER_COMPLETE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private void setFailureResponseForComplete(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_COMPLETE);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\DeleteCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.SelectiveFilterProcessor;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class DeleteCommand extends Command {
	
	private static final String MESSAGE_AFTER_DELETE = "Entry successfully deleted:";
	private static final String MESSAGE_ERROR_FOR_DELETE = "The deletion was unsuccessful.";
	
	public DeleteCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of DeleteCommand");
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		Response responseForDelete = new Response();
		if (isDeleteByIndex()) {
			IndexProcessor indexProcessorForDelete = new IndexProcessor();
			ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
			responseForDelete = indexProcessorForDelete.processInputIndex(_parameters, entries);
			if (!responseForDelete.isSuccess()) {
				return responseForDelete;
			}
			
			_logger.log(Level.INFO, "Start processing delete by index");
			responseForDelete = processDeleteByIndex();
		} else {
			_logger.log(Level.INFO, "Start processing delete by filtering");
			responseForDelete = processDeleteByFiltering();
		}
		
		if (responseForDelete.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForDelete;
	}
	
	private boolean isDeleteByIndex() {
		Parameter indexParameter = getIndexParameter();
		if (indexParameter != null) {
			return true;
		}
		
		return false; 
	}
		
	private Response processDeleteByIndex() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempStorageIndex = indexValue - 1;
		Response responseForDeleteByIndex = new Response();
		try {
			Entry entryToDelete = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			_tempStorageManipulator.deleteFromTempStorage(tempStorageIndex);
			setSuccessResponseForDeleteByIndex(responseForDeleteByIndex, entryToDelete);
			_logger.log(Level.INFO, "Generated success response for delete by index");
		} catch (IOException ex) {
			setFailureResponseForDelete(responseForDeleteByIndex);
			_logger.log(Level.INFO, "Generated failure response for delete by index");
		}
		
		return responseForDeleteByIndex;
	}
	
	private void setSuccessResponseForDeleteByIndex(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = MESSAGE_AFTER_DELETE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private void setFailureResponseForDelete(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_DELETE);
	}
	
	private Response processDeleteByFiltering() {
		SelectiveFilterProcessor selectiveFilterProcessor = new SelectiveFilterProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForFiltering = selectiveFilterProcessor.processFiltering(entries, _parameters);
		ArrayList<Entry> filteredEntries = selectiveFilterProcessor.getFilteredEntries();
		try {
			if (!filteredEntries.isEmpty()) {
				_tempStorageManipulator.deleteFromTempStorage(filteredEntries);
			}
			
			setSuccessResponseForDeleteByFiltering(responseForFiltering, filteredEntries);
			_logger.log(Level.INFO, "Generated success response for delete by filtering");
			
			return responseForFiltering;
		} catch (IOException ex) {
			Response failedResponseForDelete = new Response();
			setFailureResponseForDelete(failedResponseForDelete);
			_logger.log(Level.INFO, "Generated failure response for delete by filtering");
			
			return failedResponseForDelete;
		}
	}
	
	private void setSuccessResponseForDeleteByFiltering(Response response, ArrayList<Entry> filteredEntries) {
		String userFeedback = response.getFeedback().replace("found", "deleted");
		userFeedback = userFeedback.replace(".", ":");
		userFeedback = userFeedback.concat("<br>");
		for (int i = 0; i < filteredEntries.size(); i++) {
			Entry entry = filteredEntries.get(i);
			userFeedback = userFeedback.concat("<br>").concat(entry.toHTMLString());
		}
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\EditCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.DateTimeProcessor;
import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public class EditCommand extends Command {
	
	private static final String MESSAGE_AFTER_EDIT = "Entry successfully updated:";
	private static final String MESSAGE_FOR_UPDATED_ENTRY = "Entry after update =>";
	private static final String MESSAGE_FOR_OLD_ENTRY = "Entry before update =>";
	private static final String MESSAGE_ERROR_FOR_EDIT = "The entry could not be edited.";

	public EditCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 1;
		_logger.log(Level.INFO, "Commenced execution of EditCommand");
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
				
		IndexProcessor indexProcessorForEdit = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		Response responseForEdit = indexProcessorForEdit.processInputIndex(_parameters, entries);
		if (responseForEdit.isSuccess()) {
			_logger.log(Level.INFO, "Start process of editing entry");
			responseForEdit = processEditedDetailsForStorage();
		}
		
		if (responseForEdit.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		 
		return responseForEdit;
	}
	
	private Response processEditedDetailsForStorage() {
		ArrayList<Parameter> editedParameters = new ArrayList<Parameter>();
		Parameter newNameParameter = getNewNameParameter();
		if (newNameParameter != null) {
			newNameParameter.setParameterType(ParameterType.NAME);
			editedParameters.add(newNameParameter);
		}
		
		Parameter priorityParameter = getPriorityParameter();
		if (priorityParameter != null) {
			editedParameters.add(priorityParameter);
		}
		
		Parameter categoryParameter = getCategoryParameter();
		if (categoryParameter != null) {
			editedParameters.add(categoryParameter);
		}
		
		Response responseForEdit = new Response();
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.valueOf(index);
		if (isEditDateTimeForDeadlineTask()) {
			_logger.log(Level.INFO, "Start processing edited date time details for deadline task");
			responseForEdit = processEditedDateTimeDetailsForDeadlineTask(editedParameters, indexValue);
		} else if (isEditDateTimeForEvent()) {
			_logger.log(Level.INFO, "Start processing edited date time details for event");
			responseForEdit = processEditedDateTimeDetailsForEvent(editedParameters, indexValue);
		} else {
			boolean isEntryTypeChanged = false;
			_logger.log(Level.INFO, "Start processing edited details for storage");
			responseForEdit = updateEditedDetailsToStorage(editedParameters, indexValue, isEntryTypeChanged);
		}
		
		return responseForEdit;
	}
	
	private boolean isEditDateTimeForDeadlineTask() {
		Parameter dateParameter = getDateParameter();
		Parameter timeParameter = getTimeParameter();
		if (dateParameter != null || timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processEditedDateTimeDetailsForDeadlineTask(ArrayList<Parameter> editedParameters, 
			                                                     int index) {
		String newDate = getDetailFromParameter(getDateParameter());
		String newTime = getDetailFromParameter(getTimeParameter());
		Response responseForDateTime = new Response();
		if (isEditedEntryFloatingTask(index) || isEditedEntryEvent(index)) {
			_logger.log(Level.INFO, "Start process of converting existing entry to deadline task");
			responseForDateTime = processConversionToDeadlineTask(editedParameters, index, newDate, newTime);							                                                              
		} else if (isEditedEntryDeadlineTask(index)) {
			_logger.log(Level.INFO, "Start process of editing existing deadline task");
			responseForDateTime = processEditingDeadlineTask(editedParameters, index, newDate, newTime);
		} 
				
		return responseForDateTime;
	}
	
	private boolean isEditedEntryFloatingTask(int index) {
		if (!isEditedEntryDeadlineTask(index) && !isEditedEntryEvent(index)) {
			return true;
		}
		
		return false;
	}
	
	private boolean isEditedEntryDeadlineTask(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter dateParameter = entry.getDateParameter();
		if (dateParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private boolean isEditedEntryEvent(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startDateParameter = entry.getStartDateParameter();
		if (startDateParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processConversionToDeadlineTask(ArrayList<Parameter> editedParameters, int index, 
			                                         String newDate, String newTime) {
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		Response responseForDateTime = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(newDate, newTime);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Start validating edited date time details for deadline task");
			responseForDateTime = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(newDate, newTime);
			if (responseForDateTime.isSuccess()) {
				boolean isEntryTypeChanged = true;
				responseForDateTime = constructEditedDateTimeParametersForDeadlineTask(editedParameters, index, 
						                                                               newDate, newTime, 
						                                                               isEntryTypeChanged);
			}
		}
		
		return responseForDateTime;
	}
	
	private Response constructEditedDateTimeParametersForDeadlineTask(ArrayList<Parameter> editedParameters, 
			                                                          int index, String newDate, String newTime, 
			                                                          boolean isEntryTypeChanged) {
		addParameterToEditedParameters(editedParameters, ParameterType.DATE, newDate);
		addParameterToEditedParameters(editedParameters, ParameterType.TIME, newTime);
		_logger.log(Level.INFO, "Start processing edited details for storage");
		Response responseForDateTime = updateEditedDetailsToStorage(editedParameters, index, isEntryTypeChanged);
		
		return responseForDateTime;
	}
	
	private void addParameterToEditedParameters(ArrayList<Parameter> editedParameters,  
			                                    ParameterType parameterType, String detail) {
		if (!detail.isEmpty()) {
			Parameter parameter = new Parameter(parameterType, detail);
			editedParameters.add(parameter);
		}
	}
	
	private Response processEditingDeadlineTask(ArrayList<Parameter> editedParameters, int index, 
			                                    String newDate, String newTime) {
		if (newDate.isEmpty()) {
			newDate = getDateFromEntry(index);
		}
		if (newTime.isEmpty()) {
			newTime = getTimeFromEntry(index);
		}
		
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start validating edited date time details for deadline task");
		Response responseForDateTime = deadlineDateTimeProcessor.validateDeadlineDateTimeDetails(newDate, newTime);
		if (responseForDateTime.isSuccess()) {
			boolean isEntryTypeChanged = false;
			responseForDateTime = constructEditedDateTimeParametersForDeadlineTask(editedParameters, index, 
					                                                               newDate, newTime, 
					                                                               isEntryTypeChanged);
		}
		
		return responseForDateTime;
	}
	
	private String getDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter dateParameter = entry.getDateParameter();
		String date = dateParameter.getParameterValue();
		
		return date;
	}
	
	private String getTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter timeParameter = entry.getTimeParameter();
		String time = "";
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
		 
		return time;
	}
		
	private boolean isEditDateTimeForEvent() {
		Parameter startDateParameter = getStartDateParameter();
		Parameter startTimeParameter = getStartTimeParameter();
		Parameter endDateParameter = getEndDateParameter();
		Parameter endTimeParameter = getEndTimeParameter();
		if (startDateParameter != null || startTimeParameter != null || 
		    endDateParameter != null || endTimeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response processEditedDateTimeDetailsForEvent(ArrayList<Parameter> editedParameters, int index) {
		String newStartDate = getDetailFromParameter(getStartDateParameter());
		String newStartTime = getDetailFromParameter(getStartTimeParameter());
		String newEndDate = getDetailFromParameter(getEndDateParameter());
		String newEndTime = getDetailFromParameter(getEndTimeParameter());
		Response responseForDateTime = new Response();
		if (isEditedEntryFloatingTask(index) || isEditedEntryDeadlineTask(index)) {
			_logger.log(Level.INFO, "Start process of converting existing entry to event");
			responseForDateTime = processConversionToEvent(editedParameters, index, newStartDate, newStartTime,
					                                       newEndDate, newEndTime);							                                                              
		} else if (isEditedEntryEvent(index)) {
			_logger.log(Level.INFO, "Start process of editing existing event");
			responseForDateTime = processEditingEvent(editedParameters, index, newStartDate, newStartTime,
					                                  newEndDate, newEndTime);		 
		} 
			
		return responseForDateTime;
	}
	
	private Response processConversionToEvent(ArrayList<Parameter> editedParameters, int index, 
			                                  String newStartDate, String newStartTime, String newEndDate, 
			                                  String newEndTime) {
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		Response responseForDateTime = eventDateTimeProcessor.processEventDateTimeDetails(newStartDate, newStartTime, 
				                                                                          newEndDate, newEndTime);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			newEndDate = newStartDate;
		}
		if (responseForDateTime.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating edited date time details for event");
			responseForDateTime = eventDateTimeProcessor.validateEventDateTimeDetails(newStartDate, newStartTime, 
					                                                                  newEndDate, newEndTime);
			if (responseForDateTime.isSuccess()) {
				boolean isEntryTypeChanged = true;
				responseForDateTime = constructEditedDateTimeParametersForEvent(editedParameters, index, 
						                                                        newStartDate, newStartTime, 
						                                                        newEndDate, newEndTime,
						                                                        isEntryTypeChanged);
			}
		}
		
		return responseForDateTime;
	}
	
	private Response constructEditedDateTimeParametersForEvent(ArrayList<Parameter> editedParameters, int index,
			                                                   String newStartDate, String newStartTime, 
			                                                   String newEndDate, String newEndTime, 
			                                                   boolean isEntryTypeChanged) {                      
		addParameterToEditedParameters(editedParameters, ParameterType.START_DATE, newStartDate);
		addParameterToEditedParameters(editedParameters, ParameterType.START_TIME, newStartTime);
		addParameterToEditedParameters(editedParameters, ParameterType.END_DATE, newEndDate);
		addParameterToEditedParameters(editedParameters, ParameterType.END_TIME, newEndTime);
		_logger.log(Level.INFO, "Start processing edited details for storage");
		Response responseForDateTime = updateEditedDetailsToStorage(editedParameters, index, isEntryTypeChanged);
		
		return responseForDateTime;
	}
	
	private Response processEditingEvent(ArrayList<Parameter> editedParameters, int index, String newStartDate,
			                             String newStartTime, String newEndDate, String newEndTime) {
		if (newStartDate.isEmpty()) {
			newStartDate = getStartDateFromEntry(index);
		}
		if (newStartTime.isEmpty()) {
			newStartTime = getStartTimeFromEntry(index);
		}
		if (newEndDate.isEmpty()) {
			newEndDate = getEndDateFromEntry(index);
		}
		if (newEndTime.isEmpty()) {
			newEndTime = getEndTimeFromEntry(index);
		}
		
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start validating edited date time details for event");
		Response responseForDateTime = eventDateTimeProcessor.validateEventDateTimeDetails(newStartDate, newStartTime, 
				                                                                           newEndDate, newEndTime);
		if (responseForDateTime.isSuccess()) {
			boolean isEntryTypeChanged = false;
			responseForDateTime = constructEditedDateTimeParametersForEvent(editedParameters, index, newStartDate,  
					                                                        newStartTime, newEndDate, newEndTime,
					                                                        isEntryTypeChanged);
		}
		
		return responseForDateTime;
	}
	
	private String getStartDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startDateParameter = entry.getStartDateParameter();
		String startDate = startDateParameter.getParameterValue();
	
		return startDate;
	}
	
	private String getStartTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter startTimeParameter = entry.getStartTimeParameter();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		 
		return startTime;
	}
	
	private String getEndDateFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter endDateParameter = entry.getEndDateParameter();
		String endDate = endDateParameter.getParameterValue();
	
		return endDate;
	}
	
	private String getEndTimeFromEntry(int index) {
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage(); 
		Entry entry = entries.get(index - 1);
		Parameter endTimeParameter = entry.getEndTimeParameter();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		 
		return endTime;
	}
	
	private Response updateEditedDetailsToStorage(ArrayList<Parameter> editedParameters, int index,
			                                      boolean isEntryTypeChanged) {
		Response responseForEdit = new Response();
		try {
			int tempStorageIndex = index - 1;
			Entry oldEntry = _tempStorageManipulator.getTempStorage().get(tempStorageIndex);
			Entry entryBeforeUpdate = new Entry(oldEntry);
			Entry entryAfterUpdate = _tempStorageManipulator.editTempStorage(tempStorageIndex, editedParameters,
					                                                         isEntryTypeChanged); 
			setSuccessResponseForEdit(responseForEdit, entryBeforeUpdate, entryAfterUpdate);
			_logger.log(Level.INFO, "Generated success response for editing entry");
		} catch (IOException ex) {
			setFailureResponseForEdit(responseForEdit);
			_logger.log(Level.INFO, "Generated failure response for editing entry");
		}
		
		return responseForEdit;
	}

	private void setSuccessResponseForEdit(Response response, Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulEdit(entryBeforeUpdate, entryAfterUpdate);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulEdit(Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		String feedback = MESSAGE_AFTER_EDIT.concat("<br>").concat("<br>").concat(MESSAGE_FOR_UPDATED_ENTRY);
		feedback = feedback.concat("<br>").concat(entryAfterUpdate.toHTMLString());
		feedback = feedback.concat("<br>").concat(MESSAGE_FOR_OLD_ENTRY);
		feedback = feedback.concat("<br>").concat(entryBeforeUpdate.toHTMLString());
		
		return feedback;
	}
	
	private void setFailureResponseForEdit(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_EDIT);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\InvalidCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class InvalidCommand extends Command {
	
	private static final String MESSAGE_ERROR_INVALID_COMMAND = "Invalid command type provided.";
	
	public InvalidCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForInvalidCommand = new Response();
		responseForInvalidCommand.setIsSuccess(false);
		responseForInvalidCommand.setFeedback(MESSAGE_ERROR_INVALID_COMMAND);
		_logger.log(Level.INFO, "Generated failure response for invalid command");
		
		return responseForInvalidCommand;
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\NewCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;
import com.taskboard.main.util.Entry;

public class NewCommand extends Command {
	
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_ERROR_FOR_LAUNCH_NEW = "Failed to create new file.";
	
	private static final String TITLE_AFTER_LAUNCH = "TaskBoard: Your Revolutionary Task Manager (%1$s)";
	
	public NewCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of NewCommand");
		
		String fileName = getDetailFromParameter(getNameParameter());
		assert fileName != null;
		_logger.log(Level.INFO, "Successfully retrieved filename: " + fileName);
		
		Response responseForNew = getResponseForLaunch(fileName);
		
		if (responseForNew.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(new ArrayList<Entry>());
			_tempStorageManipulator.setLastTempArchive(new ArrayList<Entry>());
		}
		
		return responseForNew;
	}
	
	private Response getResponseForLaunch(String fileName) {
		Response responseForNew = new Response();
		
		try {
			_tempStorageManipulator.initialise(fileName);
			updateUIPreferences();
			updateUITitle(fileName);
			setSuccessResponseForLaunchNew(responseForNew, fileName);
			_logger.log(Level.INFO, "Generated success response for creating new file");
		} catch (IllegalArgumentException ex) {
			setFailureResponseForInvalidNew(responseForNew, ex);
			_logger.log(Level.INFO, "Generated failure response for creating new file with "
					    + "existing filename");
		} catch (IOException ex) {
			setFailureResponseForLaunchNew(responseForNew);
			_logger.log(Level.INFO, "Generated failure response for creating new file");
		}
		
		return responseForNew;
	}
	
	private void setSuccessResponseForLaunchNew(Response response, String fileName) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulLaunchNew(fileName);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulLaunchNew(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	private void setFailureResponseForInvalidNew(Response response, IllegalArgumentException ex) {
		response.setIsSuccess(false);
		response.setFeedback(ex.getMessage());
	}
	
	private void setFailureResponseForLaunchNew(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_LAUNCH_NEW);
	}
	
	private void updateUIPreferences() throws IOException {
		String backgroundPath = _tempStorageManipulator.getBackgroundPath();
		UserInterface.getInstance().setBackgroundPath(backgroundPath);
		int reminderHour = _tempStorageManipulator.getReminderHour();
		UserInterface.getInstance().setReminderHour(reminderHour);
	}

	private void updateUITitle(String title) {
		UserInterface.getInstance().setTitle(String.format(TITLE_AFTER_LAUNCH, title));
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\OpenCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class OpenCommand extends Command{
	
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_ERROR_FOR_LAUNCH_OPEN = "Failed to open file.";
	
	private static final String TITLE_AFTER_LAUNCH = "TaskBoard: Your Revolutionary Task Manager (%1$s)";
	
	public OpenCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of OpenCommand");
		
		String fileName = getDetailFromParameter(getNameParameter());
		assert fileName != null;
		_logger.log(Level.INFO, "Successfully retrieved filename: " + fileName);
	
		Response responseForOpen =  getResponseForLaunch(fileName);
		
		if (responseForOpen.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(new ArrayList<Entry>());
			_tempStorageManipulator.setLastTempArchive(new ArrayList<Entry>());
		}
		
		return responseForOpen;
	}
	
	private Response getResponseForLaunch(String fileName) {
		Response responseForOpen = new Response();
			
		try {
			_tempStorageManipulator.repopulate(fileName);
			updateUIPreferences();
			updateUITitle(fileName);
			setSuccessResponseForLaunchOpen(responseForOpen, fileName);
			_logger.log(Level.INFO, "Generated success response for opening existing file");
		} catch (IllegalArgumentException ex) {
			setFailureResponseForInvalidOpen(responseForOpen, ex);
			_logger.log(Level.INFO, "Generated failure response for opening non-existent file");
		} catch (IOException ex) {
			setFailureResponseForLaunchOpen(responseForOpen);
			_logger.log(Level.INFO, "Generated failure response for opening existing file");
		}
	
		return responseForOpen;
	}
	
	private void setSuccessResponseForLaunchOpen(Response response, String fileName) {
		response.setIsSuccess(true);
		String userFeedback = getFeedbackForSuccessfulLaunchOpen(fileName);
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempStorage());
	}
	
	private String getFeedbackForSuccessfulLaunchOpen(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	private void setFailureResponseForInvalidOpen(Response response, IllegalArgumentException ex) {
		response.setIsSuccess(false);
		response.setFeedback(ex.getMessage());
	}
	
	private void setFailureResponseForLaunchOpen(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_LAUNCH_OPEN);
	}
	
	private void updateUIPreferences() throws IOException {
		String backgroundPath = _tempStorageManipulator.getBackgroundPath();
		UserInterface.getInstance().setBackgroundPath(backgroundPath);
		int reminderHour = _tempStorageManipulator.getReminderHour();
		UserInterface.getInstance().setReminderHour(reminderHour);
	}

	private void updateUITitle(String title) {
		UserInterface.getInstance().setTitle(String.format(TITLE_AFTER_LAUNCH, title));
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\RestoreCommand.java
``` java
package com.taskboard.main.command;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.IndexProcessor;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class RestoreCommand extends Command {
	
	private static final String MESSAGE_AFTER_RESTORE = "Entry successfully restored:";
	private static final String MESSAGE_ERROR_FOR_RESTORE = "The entry could not be restored.";
	
	public RestoreCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		assert _parameters.size() > 0;
		_logger.log(Level.INFO, "Commenced execution of RestoreCommand");
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		IndexProcessor indexProcessorForRestore = new IndexProcessor();
		ArrayList<Entry> entries = _tempStorageManipulator.getTempArchive();
		Response responseForRestore = indexProcessorForRestore.processInputIndex(_parameters, entries);
		if (responseForRestore.isSuccess()) {
			_logger.log(Level.INFO, "Start process of restoring entry");
			responseForRestore = processRestoringOfEntry();
		}
		
		if (responseForRestore.isSuccess()) {
			_tempStorageManipulator.setLastTempStorage(initialTempStorage);
			_tempStorageManipulator.setLastTempArchive(initialTempArchive);
		}
		
		return responseForRestore;
	}
	
	private Response processRestoringOfEntry() {
		String index = getDetailFromParameter(getIndexParameter());
		int indexValue = Integer.parseInt(index);
		int tempArchiveIndex = indexValue - 1;
		Response responseForRestore = new Response();
		try {
			Entry entryToRestore = _tempStorageManipulator.getTempArchive().get(tempArchiveIndex);
			_tempStorageManipulator.restoreToTempStorage(tempArchiveIndex);
			setSuccessResponseForRestore(responseForRestore, entryToRestore);
			_logger.log(Level.INFO, "Generated success response for restoring entry");
		} catch (IOException ex) {
			setFailureResponseForRestore(responseForRestore);
			_logger.log(Level.INFO, "Generated failure response for restoring entry");
		}
		
		return responseForRestore;
	}
	
	private void setSuccessResponseForRestore(Response response, Entry entry) {
		response.setIsSuccess(true);
		String userFeedback = MESSAGE_AFTER_RESTORE.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		response.setFeedback(userFeedback);
		response.setEntries(_tempStorageManipulator.getTempArchive());
	}
	
	private void setFailureResponseForRestore(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_RESTORE);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\ViewCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.SelectiveFilterProcessor;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class ViewCommand extends Command {
	
	private static final String MESSAGE_EMPTY_FILE = "There are no registered entries.";
	private static final String MESSAGE_RETRIEVE_SUCCESS = "Successfully retrieved all entries.";

	public ViewCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	 
	public Response executeCommand() {
		_logger.log(Level.INFO, "Commenced execution of ViewCommand");
		Response responseForView = new Response();
		if (isViewWithoutFilter()) {
			setSuccessResponseForViewWithoutFilter(responseForView);
			_logger.log(Level.INFO, "Generated success response for view without filter");
		} else {
			_logger.log(Level.INFO, "Start processing view with filter");
			SelectiveFilterProcessor selectiveFilterProcessor = new SelectiveFilterProcessor();
			ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
			responseForView = selectiveFilterProcessor.processFiltering(entries, _parameters);
		}
		
		return responseForView;
	}
	
	private boolean isViewWithoutFilter() {
		if (_parameters.isEmpty()) {
			return true;
		}
		
		return false;
	}
	
	private void setSuccessResponseForViewWithoutFilter(Response response) {
		response.setIsSuccess(true);
		ArrayList<Entry> entries = _tempStorageManipulator.getTempStorage();
		response.setEntries(entries);
		if (entries.isEmpty()) {
			response.setFeedback(MESSAGE_EMPTY_FILE);
		} else {
			response.setFeedback(MESSAGE_RETRIEVE_SUCCESS);
		}
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\DateTimeProcessor.java
``` java
package com.taskboard.main;

import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Response;

public class DateTimeProcessor {
	
	private static final String MESSAGE_ERROR_FOR_NO_DATE = "No date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_START_DATE = "No start date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_END_DATE_TIME = "No end date time provided.";
	
	// attribute
	
	private Logger _logger;
	
	// constructor
	
	public DateTimeProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response processDeadlineDateTimeDetails(String date, String time) {
		Response responseForDateTime = new Response();
		if (date.isEmpty()) {
			setFailureResponseForNoDate(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no date");
		} else {
			responseForDateTime.setIsSuccess(true);
		}
		
		return responseForDateTime;
	}
	
	private void setFailureResponseForNoDate(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_DATE);
	}
	
	public Response validateDeadlineDateTimeDetails(String date, String time) {
		DateTimeValidator deadlineDateTimeValidator = new DateTimeValidator();
		Date currentDate = new Date();
		Response responseForDateTime = deadlineDateTimeValidator.validateDateTimeDetails(date, time, currentDate);
		
		return responseForDateTime;
	}
	
	public Response processEventDateTimeDetails(String startDate, String startTime, String endDate, 
			                                    String endTime) {
		Response responseForDateTime = new Response();
		if (startDate.isEmpty()) {
			setFailureResponseForNoStartDate(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no start date");
		} else if (endDate.isEmpty() && endTime.isEmpty()) {
			setFailureResponseForNoEndDateTime(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for no end date time");
		} else if (endDate.isEmpty()) {
			responseForDateTime.setIsSuccess(true);
		}
		
		return responseForDateTime;
	}
	
	private void setFailureResponseForNoStartDate(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_START_DATE);
	}
	
	private void setFailureResponseForNoEndDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_NO_END_DATE_TIME);
	}
	
	public Response validateEventDateTimeDetails(String startDate, String startTime, String endDate, 
			                                     String endTime) {
		DateTimeValidator startDateTimeValidator = new DateTimeValidator();
		Date currentDate = new Date();
		Response responseForDateTime = startDateTimeValidator.validateDateTimeDetails(startDate, startTime, 
				                                                                      currentDate);
		if (responseForDateTime.isSuccess() == true) {
			DateTimeValidator endDateTimeValidator = new DateTimeValidator();
			Date inputStartDate = startDateTimeValidator.getDate();
			responseForDateTime = endDateTimeValidator.validateDateTimeDetails(endDate, endTime, inputStartDate);
		}
		
		return responseForDateTime;
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\DateTimeValidator.java
``` java
package com.taskboard.main;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Response;

public class DateTimeValidator {
	
	private static final String MESSAGE_ERROR_FOR_INVALID_DATE_TIME = "Invalid date time provided.";
	private static final String MESSAGE_ERROR_FOR_PAST_DATE_TIME = "Past date time provided.";
	
	private static final String FORMAT_DEFAULT_TIME = "23:59";
	private static final String FORMAT_DATE_TIME = "dd/MM/yyyy'T'HH:mm";
	
	// attribute
	
	private Date _inputDate;
	private Logger _logger;
	
	// constructor
	
	public DateTimeValidator() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// accessor
	
	public Date getDate() {
		return _inputDate;
	}
	
	public Response validateDateTimeDetails(String date, String time, Date referenceDate) {
		Response responseForDateTime = new Response();
		
		String dateTime = getDateTimeFormat(date, time);
		_inputDate = getInputDate(dateTime);
		if (_inputDate == null) {
			setFailureResponseForInvalidDateTime(responseForDateTime);
			_logger.log(Level.INFO, "Generated failure response for invalid date time");
		} else if (referenceDate != null){
			responseForDateTime = checkValidityOfInputDate(referenceDate);
		}
		
		return responseForDateTime;
	}
	
	private String getDateTimeFormat(String date, String time) {
		if (time.isEmpty()) {
			time = FORMAT_DEFAULT_TIME;
		}
		String dateTime = date.concat("T").concat(time);
		
		return dateTime;
	}
	
	private Date getInputDate(String dateTime) {
		 try {
			 DateFormat dateFormat = new SimpleDateFormat(FORMAT_DATE_TIME);
	         dateFormat.setLenient(false);
	         Date inputDate = dateFormat.parse(dateTime);
 	         
	         return inputDate;
	     } catch (ParseException e) {
	         return null;
	     }
	}
	
	private void setFailureResponseForInvalidDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_INVALID_DATE_TIME);
	}
	
	private Response checkValidityOfInputDate(Date referenceDate) {
		Response responseForInputDate = new Response();
		if (_inputDate.after(referenceDate)) {
			responseForInputDate.setIsSuccess(true);
		} else {
			setFailureResponseForPastDateTime(responseForInputDate);
			_logger.log(Level.INFO, "Generated failure response for past date time");
		}
			
		return responseForInputDate;
	}
	
	private void setFailureResponseForPastDateTime(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\IndexProcessor.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public class IndexProcessor {
	
	private static final String MESSAGE_ERROR_FOR_INVALID_INDEX = "Invalid index provided.";
	
	private static final int MIN_ENTRY_INDEX = 1;
	
	// attribute
	
	private Logger _logger;
	
	// constructor
	
	public IndexProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response processInputIndex(ArrayList<Parameter> parameters, ArrayList<Entry> entries) {
		String inputIndex = "";
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.INDEX) {
				inputIndex = parameters.get(i).getParameterValue(); 
			}
		}
		
		assert !inputIndex.isEmpty();
		_logger.log(Level.INFO, "Successfully retrieved index of entry: " + inputIndex);
		Response responseForInputIndex = checkValidityOfInputIndex(inputIndex, entries);
		
		return responseForInputIndex;
	}
	
	private Response checkValidityOfInputIndex(String index, ArrayList<Entry> entries) {
		int indexValue = Integer.valueOf(index);
		int maxEntryIndex = entries.size();
		Response responseForInputIndex = new Response();
		if (indexValue > maxEntryIndex || indexValue < MIN_ENTRY_INDEX) {
			setFailureResponseForInvalidIndex(responseForInputIndex);
			_logger.log(Level.INFO, "Generated failure response for invalid index");
		} else {
			responseForInputIndex.setIsSuccess(true);
		}
		
		return responseForInputIndex;
	}
	
	private void setFailureResponseForInvalidIndex(Response response) {
		response.setIsSuccess(false);
		response.setFeedback(MESSAGE_ERROR_FOR_INVALID_INDEX);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\Logic.java
``` java
package com.taskboard.main;

import com.taskboard.main.command.Command;
import com.taskboard.main.parser.CommandParser;
import com.taskboard.main.util.Response;

public class Logic {
	
	// attribute
	
	private CommandParser _commandParser;
	
	// constructor
	
	public Logic() {
		_commandParser = new CommandParser();
	}
		
	public Response processCommand(String userInput) {
		Response responseForOperations = new Response();
		
		try {
			Command commandInput = _commandParser.parseCommand(userInput);
			responseForOperations = commandInput.executeCommand();
		} catch (IllegalArgumentException ex) {
			responseForOperations.setIsSuccess(false);
			responseForOperations.setFeedback(ex.getMessage());
		}
		
		return responseForOperations; 
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\SelectiveFilter.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;

public class SelectiveFilter {
	
	private static final String FORMAT_DEADLINE_TASK_DEFAULT_TIME_FOR_FILTER_BY_DATE = "00:00";
	private static final String FORMAT_EVENT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE = "00:00";
	private static final String FORMAT_EVENT_DEFAULT_END_TIME_FOR_FILTER_BY_DATE = "23:59";
	
	// attribute
	
	private Logger _logger;

	// constructor
	
	public SelectiveFilter() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Entry> filterByName(ArrayList<Entry> entries, String searchKey) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			String entryName = entry.getNameParameter().getParameterValue();
			if (entryName.toLowerCase().contains(searchKey.toLowerCase())) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by name: " + entryName);
			}
		}
		
		return filteredEntries;
	}
	
	public ArrayList<Entry> filterByPriority(ArrayList<Entry> entries, String searchPriority) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter priorityParameter = entry.getPriorityParameter();
			if (priorityParameter != null) {
				String priority = priorityParameter.getParameterValue();
				if (priority.equals(searchPriority)) {
					filteredEntries.add(entry);
					_logger.log(Level.INFO, "Successfully filtered entry by priority: " 
					            + entry.getNameParameter().getParameterValue());
				}
			}
		} 
		
		return filteredEntries;
	}
	
	public ArrayList<Entry> filterByCategory(ArrayList<Entry> entries, String searchCategory) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter categoryParameter = entry.getCategoryParameter();
			if (categoryParameter != null) {
				String category = categoryParameter.getParameterValue();
				if (category.equalsIgnoreCase(searchCategory)) {
					filteredEntries.add(entry);
					_logger.log(Level.INFO, "Successfully filtered entry by category: " 
				                + entry.getNameParameter().getParameterValue());
				}
			}
		} 
		
		return filteredEntries;
	}
	
	public ArrayList<Entry> filterByDate(ArrayList<Entry> entries, Date inputDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			
			boolean hasDeadlineDateMatched = false;
			boolean hasEventDateMatched = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
					        + entry.getNameParameter().getParameterValue());
				hasDeadlineDateMatched = hasDeadlineDateMatched(dateParameter, inputDate);
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
					        + entry.getNameParameter().getParameterValue());
			    hasEventDateMatched = hasEventDateMatched(startDateParameter, endDateParameter,  
					                                      inputDate); 		
			}
			
			if (hasDeadlineDateMatched || hasEventDateMatched) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date: " 
		                    + entry.getNameParameter().getParameterValue());
			}
		}
			
		return filteredEntries;
	}
		
	private boolean hasDeadlineDateMatched(Parameter dateParameter, Date referenceDate) {
		String date = dateParameter.getParameterValue();
		String time = FORMAT_DEADLINE_TASK_DEFAULT_TIME_FOR_FILTER_BY_DATE;
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		if (deadlineDate.equals(referenceDate)) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date");
			return true;
		}
	
		return false;
	}
	
	private Date retrieveDateFromDateTimeDetails(String date, String time) {
		DateTimeValidator dateTimeValidator = new DateTimeValidator();
		dateTimeValidator.validateDateTimeDetails(date, time, null);
		Date convertedDate = dateTimeValidator.getDate();
		
		return convertedDate;
	}
	
	private boolean hasEventDateMatched(Parameter startDateParameter, Parameter endDateParameter,
			                            Date referenceDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = FORMAT_EVENT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE;
		String endDate = endDateParameter.getParameterValue();
		String endTime = FORMAT_EVENT_DEFAULT_END_TIME_FOR_FILTER_BY_DATE;
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceDate);
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceDate);
		if (referenceDateIndicatorForEventStartDate <= 0 && referenceDateIndicatorForEventEndDate >= 0) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date");
			return true;
		}
		
		return false;
		
	}
	
	public ArrayList<Entry> filterByDateTime(ArrayList<Entry> entries, Date inputDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter timeParameter = entry.getTimeParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter startTimeParameter = entry.getStartTimeParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			Parameter endTimeParameter = entry.getEndTimeParameter();
			
			boolean hasDeadlineDateTimeMatched = false;
			boolean hasEventDateTimeMatched = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
						    + entry.getNameParameter().getParameterValue());
				hasDeadlineDateTimeMatched = hasDeadlineDateTimeMatched(dateParameter, timeParameter, 
						                                                inputDate); 
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
						    + entry.getNameParameter().getParameterValue());
				hasEventDateTimeMatched = hasEventDateTimeMatched(startDateParameter, startTimeParameter, 
						                                          endDateParameter, endTimeParameter, 
						                                          inputDate); 				                                         
			}
			
			if (hasDeadlineDateTimeMatched || hasEventDateTimeMatched) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date time: " 
		                    + entry.getNameParameter().getParameterValue());
			}
		}
		
		return filteredEntries;
	}
	
	private boolean hasDeadlineDateTimeMatched(Parameter dateParameter, Parameter timeParameter, 
			                                   Date referenceDate) {
		String date = dateParameter.getParameterValue();
		String time = "";	
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
		
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		if (deadlineDate.equals(referenceDate)) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date time");
			return true;
		}
	
		return false;
	}
				
	private boolean hasEventDateTimeMatched(Parameter startDateParameter, Parameter startTimeParameter,
			                                Parameter endDateParameter, Parameter endTimeParameter, 
			                                Date referenceDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		String endDate = endDateParameter.getParameterValue();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceDate);
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceDate);
		if (referenceDateIndicatorForEventStartDate <= 0 && referenceDateIndicatorForEventEndDate >= 0) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date time");
			return true;
		}
		
		return false;
	}
	
	public ArrayList<Entry> filterByDateTimeRange(ArrayList<Entry> entries, Date inputStartDate, 
			                                      Date inputEndDate) {
		ArrayList<Entry> filteredEntries = new ArrayList<Entry>();
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter dateParameter = entry.getDateParameter();
			Parameter timeParameter = entry.getTimeParameter();
			Parameter startDateParameter = entry.getStartDateParameter();
			Parameter startTimeParameter = entry.getStartTimeParameter();
			Parameter endDateParameter = entry.getEndDateParameter();
			Parameter endTimeParameter = entry.getEndTimeParameter();
			
			boolean isDeadlineDateTimeInRange = false;
			boolean isEventDateTimeInRange = false;
			if (dateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter deadline task: "
					        + entry.getNameParameter().getParameterValue());
				isDeadlineDateTimeInRange = isDeadlineDateTimeInRange(dateParameter, timeParameter,  
						                                              inputStartDate, inputEndDate);
			} else if (startDateParameter != null) {
				_logger.log(Level.INFO, "Start checking whether to filter event: "
					        + entry.getNameParameter().getParameterValue());
				isEventDateTimeInRange = isEventDateTimeInRange(startDateParameter, startTimeParameter,  
				                                                endDateParameter, endTimeParameter,
				                                                inputStartDate,  inputEndDate);
			}
			
			if (isDeadlineDateTimeInRange || isEventDateTimeInRange) {
				filteredEntries.add(entry);
				_logger.log(Level.INFO, "Successfully filtered entry by date time range: " 
	                        + entry.getNameParameter().getParameterValue());
			}
		}
		
		return filteredEntries;
	}
		
	private boolean isDeadlineDateTimeInRange(Parameter dateParameter, Parameter timeParameter, 
			                                  Date referenceStartDate, Date referenceEndDate) {
		String date = dateParameter.getParameterValue();
		String time = "";
		if (timeParameter != null) {
			time = timeParameter.getParameterValue();
		}
			
		Date deadlineDate = retrieveDateFromDateTimeDetails(date, time);
		int referenceStartDateIndicator = deadlineDate.compareTo(referenceStartDate);
		int referenceEndDateIndicator = deadlineDate.compareTo(referenceEndDate);
		if (referenceStartDateIndicator >= 0 && referenceEndDateIndicator <= 0) {
			_logger.log(Level.INFO, "Deadline task successfully satisfied filter by date time range");
			return true;
		}
	
		return false;
	}
	
	private boolean isEventDateTimeInRange(Parameter startDateParameter, Parameter startTimeParameter,
			                               Parameter endDateParameter, Parameter endTimeParameter, 
			                               Date referenceStartDate, Date referenceEndDate) {
		String startDate = startDateParameter.getParameterValue();
		String startTime = "";
		if (startTimeParameter != null) {
			startTime = startTimeParameter.getParameterValue();
		}
		String endDate = endDateParameter.getParameterValue();
		String endTime = "";
		if (endTimeParameter != null) {
			endTime = endTimeParameter.getParameterValue();
		}
		
		Date eventStartDate = retrieveDateFromDateTimeDetails(startDate, startTime);
		int referenceStartDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceStartDate);
		int referenceEndDateIndicatorForEventStartDate = eventStartDate.compareTo(referenceEndDate);
		boolean isEventStartDateInSearchRange = referenceStartDateIndicatorForEventStartDate >= 0 && 
				                                referenceEndDateIndicatorForEventStartDate <= 0;
		
		Date eventEndDate = retrieveDateFromDateTimeDetails(endDate, endTime);
		int referenceStartDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceStartDate);
		int referenceEndDateIndicatorForEventEndDate = eventEndDate.compareTo(referenceEndDate);
		boolean isEventEndDateInSearchRange = referenceStartDateIndicatorForEventEndDate >= 0 && 
				                              referenceEndDateIndicatorForEventEndDate <= 0;
		
		boolean isSearchRangeInEventRange = referenceStartDateIndicatorForEventStartDate < 0 && 
			                            	referenceEndDateIndicatorForEventEndDate > 0;
		
		if (isEventStartDateInSearchRange || isEventEndDateInSearchRange || isSearchRangeInEventRange) {
			_logger.log(Level.INFO, "Event successfully satisfied filter by date time range");
			return true;
		}
		
		return false;
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\SelectiveFilterProcessor.java
``` java
package com.taskboard.main;

import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public class SelectiveFilterProcessor {
	
	private static final String MESSAGE_FILTER_RESULTS = "entries found based on search results!";
	
	private static final String FORMAT_DEFAULT_TIME_FOR_FILTER_BY_DATE = "00:00";
	private static final String FORMAT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE_TIME_RANGE = "00:00";
	
	// attribute
	
	private ArrayList<Entry> _filteredEntries;
	private Logger _logger;
	
	// constructor
	
	public SelectiveFilterProcessor() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	// accessor
	
	public ArrayList<Entry> getFilteredEntries() {
		return _filteredEntries;
	}
	
	public Response processFiltering(ArrayList<Entry> entries, ArrayList<Parameter> parameters) {
		_filteredEntries = entries;
		if (isFilterByName(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by name");
			_filteredEntries = processFilterByName(parameters);
		}
		
		if (isFilterByPriority(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by priority");
			_filteredEntries = processFilterByPriority(parameters);
		}
		
		if (isFilterByCategory(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by category");
			_filteredEntries = processFilterByCategory(parameters);
		}
		
		Response responseForFiltering = new Response();
		if (isFilterByDate(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date");
			DateTimeValidator dateValidator = new DateTimeValidator();
			responseForFiltering = checkForDateValidity(dateValidator, parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDate(dateValidator);
		}
		
		if (isFilterByDateTime(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date time");
			DateTimeValidator dateTimeValidator = new DateTimeValidator();
			responseForFiltering = checkForDateTimeValidity(dateTimeValidator, parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDateTime(dateTimeValidator); 
		}
		
		if (isFilterByDateTimeRange(parameters)) {
			_logger.log(Level.INFO, "Start processing filter by date time range");
			DateTimeValidator startDateTimeValidator = new DateTimeValidator();
			DateTimeValidator endDateTimeValidator = new DateTimeValidator();
			responseForFiltering = checkForDateTimeValidity(startDateTimeValidator, endDateTimeValidator,
					                                        parameters);
			if (responseForFiltering.getFeedback() != null) {
				return responseForFiltering;
			}
			
			_filteredEntries = processFilterByDateTimeRange(startDateTimeValidator, 
					                                        endDateTimeValidator);
		}
		
		setSuccessResponseForViewWithFilter(responseForFiltering);
		
		return responseForFiltering;
	}
	
	private boolean isFilterByName(ArrayList<Parameter> parameters) {
		Parameter nameParameter = getNameParameter(parameters);
		if (nameParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getNameParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.NAME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByName(ArrayList<Parameter> parameters) {
		String searchKey = getDetailFromParameter(getNameParameter(parameters));
		SelectiveFilter selectiveFilterByName = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByName.filterByName(_filteredEntries, searchKey);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
		            + " entries by name");
		
		return filteredEntries;
	}
	
	private String getDetailFromParameter(Parameter parameter) {
		String detail = "";
		if (parameter != null) {
			detail = parameter.getParameterValue();
		}
		
		return detail;
	}
	
	private boolean isFilterByPriority(ArrayList<Parameter> parameters) {
		Parameter priorityParameter = getPriorityParameter(parameters);
		if (priorityParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getPriorityParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByPriority(ArrayList<Parameter> parameters) {
		String searchPriority = getDetailFromParameter(getPriorityParameter(parameters));
		SelectiveFilter selectiveFilterByPriority = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByPriority.filterByPriority(_filteredEntries, 
				                                                                      searchPriority);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by priority");
		
		return filteredEntries;
	}
	
	private boolean isFilterByCategory(ArrayList<Parameter> parameters) {
		Parameter categoryParameter = getCategoryParameter(parameters);
		if (categoryParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getCategoryParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private ArrayList<Entry> processFilterByCategory(ArrayList<Parameter> parameters) {
		String searchCategory = getDetailFromParameter(getCategoryParameter(parameters));
		SelectiveFilter selectiveFilterByCategory = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByCategory.filterByCategory(_filteredEntries, 
				                                                                      searchCategory); 
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
        			+ " entries by category");
		
		return filteredEntries;
	}
	
	private boolean isFilterByDate(ArrayList<Parameter> parameters) {
		Parameter dateParameter = getDateParameter(parameters);
		Parameter timeParameter = getTimeParameter(parameters);
		if (dateParameter != null && timeParameter == null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Response checkForDateValidity(DateTimeValidator dateValidator, ArrayList<Parameter> parameters) {
		String date = getDetailFromParameter(getDateParameter(parameters));
		String time = FORMAT_DEFAULT_TIME_FOR_FILTER_BY_DATE; 
		_logger.log(Level.INFO, "Start validating date");
		Response responseForDate = dateValidator.validateDateTimeDetails(date, time, null);
		
		return responseForDate;
	}
	
	private ArrayList<Entry> processFilterByDate(DateTimeValidator dateValidator) {
		Date inputDate = dateValidator.getDate();
		SelectiveFilter selectiveFilterByDate = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDate.filterByDate(_filteredEntries, 
				                                                              inputDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date");

		return filteredEntries;
	}
		
	private boolean isFilterByDateTime(ArrayList<Parameter> parameters) {
		Parameter timeParameter = getTimeParameter(parameters);
		if (timeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Response checkForDateTimeValidity(DateTimeValidator dateTimeValidator, 
			                                  ArrayList<Parameter> parameters) { 
		String date = getDetailFromParameter(getDateParameter(parameters));
		String time = getDetailFromParameter(getTimeParameter(parameters));	
		DateTimeProcessor deadlineDateTimeProcessor = new DateTimeProcessor();
		_logger.log(Level.INFO, "Start processing date time details");
		Response responseForDateTime = deadlineDateTimeProcessor.processDeadlineDateTimeDetails(date, time);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Start validating date time details");
			responseForDateTime = dateTimeValidator.validateDateTimeDetails(date, time, null);
		}
		
		return responseForDateTime;
	}
	
	private ArrayList<Entry> processFilterByDateTime(DateTimeValidator dateTimeValidator) {
		Date inputDate = dateTimeValidator.getDate();
		SelectiveFilter selectiveFilterByDateTime = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDateTime.filterByDateTime(_filteredEntries, 
				                                                                      inputDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date time");
		
		return filteredEntries;
	}
		
	private boolean isFilterByDateTimeRange(ArrayList<Parameter> parameters) {
		Parameter startDateParameter = getStartDateParameter(parameters);
		Parameter startTimeParameter = getStartTimeParameter(parameters);
		Parameter endDateParameter = getEndDateParameter(parameters);
	    Parameter endTimeParameter = getEndTimeParameter(parameters);
		if (startDateParameter != null || startTimeParameter != null || endDateParameter != null || 
	        endTimeParameter != null) {
			return true;
		}
		
		return false;
	}
	
	private Parameter getStartDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getStartTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getEndDateParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Parameter getEndTimeParameter(ArrayList<Parameter> parameters) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return parameters.get(i);
			}
		}
		
		return null;
	}
	
	private Response checkForDateTimeValidity(DateTimeValidator startDateTimeValidator, 
			                                  DateTimeValidator endDateTimeValidator, 
			                                  ArrayList<Parameter> parameters) {
		String startDate = getDetailFromParameter(getStartDateParameter(parameters));
		String startTime = getDetailFromParameter(getStartTimeParameter(parameters));
		String endDate = getDetailFromParameter(getEndDateParameter(parameters));
		String endTime = getDetailFromParameter(getEndTimeParameter(parameters));
		DateTimeProcessor eventDateTimeProcessor = new DateTimeProcessor();
		if (startTime.isEmpty()) {
			startTime = FORMAT_DEFAULT_START_TIME_FOR_FILTER_BY_DATE_TIME_RANGE; 
		}
		
		_logger.log(Level.INFO, "Start processing range of date time details");
		Response responseForDateTime = eventDateTimeProcessor.processEventDateTimeDetails(startDate, startTime, 
				                                                                          endDate, endTime);
		if (responseForDateTime.isSuccess()) {
			_logger.log(Level.INFO, "Assign start date to end date");
			endDate = startDate;
		}
		if (responseForDateTime.getFeedback() == null) {
			_logger.log(Level.INFO, "Start validating start date time details");
			responseForDateTime = startDateTimeValidator.validateDateTimeDetails(startDate, startTime, null);	
			if (responseForDateTime.getFeedback() == null) {
				Date inputStartDate = startDateTimeValidator.getDate();
				_logger.log(Level.INFO, "Start validating end date time details");
				responseForDateTime = endDateTimeValidator.validateDateTimeDetails(endDate, endTime, 
						                                                           inputStartDate);
			}
		}
		
		return responseForDateTime;
	}
		
	private ArrayList<Entry> processFilterByDateTimeRange(DateTimeValidator startDateTimeValidator,
			                                              DateTimeValidator endDateTimeValidator) {
		Date inputStartDate = startDateTimeValidator.getDate();
		Date inputEndDate = endDateTimeValidator.getDate();
		SelectiveFilter selectiveFilterByDateTimeRange = new SelectiveFilter();
		ArrayList<Entry> filteredEntries = selectiveFilterByDateTimeRange.filterByDateTimeRange(_filteredEntries, 
				                                                                                inputStartDate,
				                                                                                inputEndDate);
		_logger.log(Level.INFO, "Successfully filtered " + String.valueOf(filteredEntries.size())
                    + " entries by date time range");
		
		return filteredEntries;
	}
	
	private void setSuccessResponseForViewWithFilter(Response response) {
		response.setIsSuccess(true);
		int numOfFilteredEntries = _filteredEntries.size();
		String userFeedback = String.valueOf(numOfFilteredEntries).concat(" ").concat(MESSAGE_FILTER_RESULTS);
		if (numOfFilteredEntries == 1) {
			userFeedback = userFeedback.replace("entries", "entry");
		}
		response.setFeedback(userFeedback);
		response.setEntries(_filteredEntries);
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\Response.java
``` java
package com.taskboard.main.util;

import java.util.ArrayList;

public class Response {
	
	// attributes
	
	private boolean _isSuccess;
	private String _feedback;
	private ArrayList<Entry> _entries;
	
	// constructor
	
	public Response() {		
	
	}
	
	// accessors 
	
	public boolean isSuccess() {
		return _isSuccess;
	}
	
	public String getFeedback() {
		return _feedback;
	}
	
	public ArrayList<Entry> getEntries() {
		return _entries;
	}
	
	// mutators
	
	public void setIsSuccess(boolean isSuccess) {
		_isSuccess = isSuccess;	
	}
	
	public void setFeedback(String feedback) {
		_feedback = feedback;
	}
	
	public void setEntries(ArrayList<Entry> entries) {
		_entries = entries;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Response) {
			Response response = (Response) obj;
			
			boolean isEqual;
			if (this.isSuccess() == true) {
				isEqual = this._isSuccess == response._isSuccess && 
						  this._feedback.equals(response._feedback) &&
						  this.retrieveEntryDetails(this._entries).equals(response.retrieveEntryDetails(response._entries));
			} else {
				isEqual = this._isSuccess == response._isSuccess &&
						  this._feedback.equals(response._feedback);
			}
			
			return isEqual;
		}
		
		return false;
	}
	
	private String retrieveEntryDetails(ArrayList<Entry> entries) {
		String entryDetails = "";
		
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			entryDetails = entryDetails.concat(entry.toString());
		}
		
		return entryDetails;
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\test\LogicTest.java
``` java
package com.taskboard.test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.Before;
import org.junit.After;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;

import com.taskboard.main.Logic;
import com.taskboard.main.comparator.DateComparator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;
import com.taskboard.main.util.Response;

public class LogicTest {
	
	private static final String MESSAGE_WELCOME = "Welcome to TASKBOARD!";
	private static final String MESSAGE_FOR_FILENAME = "Scheduler \"%1$s\" is ready for use.";
	private static final String MESSAGE_AFTER_ADD = "Entry successfully added:";
	private static final String MESSAGE_AFTER_EDIT = "Entry successfully updated:";
	private static final String MESSAGE_FOR_UPDATED_ENTRY = "Entry after update =>";
	private static final String MESSAGE_FOR_OLD_ENTRY = "Entry before update =>";
	private static final String MESSAGE_ERROR_FOR_CREATING_EXISTNG_FILE = "The file already exists.";
	private static final String MESSAGE_ERROR_FOR_OPENING_NON_EXISTING_FILE = "The file does not exists.";
	private static final String MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND = "No parameters provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_PRI_PARAMETER = "Empty pri parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_BY_PARAMETER = "Empty by parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_CAT_PARAMETER = "Empty cat parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_FROM_PARAMETER = "Empty from parameter provided.";
	private static final String MESSAGE_ERROR_FOR_EMPTY_TO_PARAMETER = "Empty to parameter provided.";
	private static final String MESSAGE_ERROR_FOR_NO_DATE = "No date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_START_DATE = "No start date provided.";
	private static final String MESSAGE_ERROR_FOR_NO_END_DATE_TIME = "No end date time provided.";
	private static final String MESSAGE_ERROR_FOR_PAST_DATE_TIME = "Past date time provided.";
	private static final String MESSAGE_ERROR_FOR_NO_EDITED_DETAILS = "No edited details provided.";
	private static final String MESSAGE_ERROR_FOR_INVALID_INDEX = "Invalid index provided.";
	
	private File testStorageFileForNew;
	private File testArchiveFileForNew;
	private File testPreferenceFileForNew;
	private File testStorageFileForOpen;
	private File testArchiveFileForOpen;
	private File testPreferenceFileForOpen;
	private ArrayList<Entry> expectedEntries; 
	private Logic logic;
	
	@Before 
	public void setUp() throws IOException {
		logic = new Logic();
		
		testStorageFileForNew = new File("testNew" + ".str");
		testStorageFileForNew.createNewFile();
		testArchiveFileForNew = new File("testNew" + ".arc");
		testArchiveFileForNew.createNewFile();
		testPreferenceFileForNew = new File("testNew" + ".pref");
		testPreferenceFileForNew.createNewFile();
		
		testStorageFileForOpen = new File("testOpen" + ".str");
		testStorageFileForOpen.createNewFile();
		testArchiveFileForOpen = new File("testOpen" + ".arc");
		testArchiveFileForOpen.createNewFile();
		testPreferenceFileForOpen = new File("testOpen" + ".pref");
		testPreferenceFileForOpen.createNewFile();
		
		Entry event1 = new Entry();
		event1.addToParameters(new Parameter(ParameterType.INDEX, "1"));
		event1.addToParameters(new Parameter(ParameterType.NAME, "Quaterly Meeting"));
		event1.addToParameters(new Parameter(ParameterType.START_DATE, "03/03/2016"));
		event1.addToParameters(new Parameter(ParameterType.START_TIME, "10:00"));
		event1.addToParameters(new Parameter(ParameterType.END_DATE, "03/03/2016"));
		event1.addToParameters(new Parameter(ParameterType.END_TIME, "11:30"));
		event1.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event1.addToParameters(new Parameter(ParameterType.CATEGORY, "Finance"));
		expectedEntries = new ArrayList<Entry>();
		expectedEntries.add(event1);
		
		Entry event2 = new Entry();
		event2.addToParameters(new Parameter(ParameterType.INDEX, "2"));
		event2.addToParameters(new Parameter(ParameterType.NAME, "Annual Meeting"));
		event2.addToParameters(new Parameter(ParameterType.START_DATE, "14/04/2016"));
		event2.addToParameters(new Parameter(ParameterType.START_TIME, "09:00"));
		event2.addToParameters(new Parameter(ParameterType.END_DATE, "14/04/2016"));
		event2.addToParameters(new Parameter(ParameterType.END_TIME, "11:00"));
		event2.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event2.addToParameters(new Parameter(ParameterType.CATEGORY, "Marketing"));
		expectedEntries.add(event2);
		
		Entry deadlineTask1 = new Entry();
		deadlineTask1.addToParameters(new Parameter(ParameterType.INDEX, "3"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.NAME, "Complete annual feedback survey"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.DATE, "25/04/2016"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.TIME, "14:00"));
		deadlineTask1.addToParameters(new Parameter(ParameterType.PRIORITY, "low"));
		expectedEntries.add(deadlineTask1);
		
		Entry deadlineTask2 = new Entry();
		deadlineTask2.addToParameters(new Parameter(ParameterType.INDEX, "4"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.NAME, "Annual company dinner"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.DATE, "02/05/2016"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.TIME, "18:00"));
		deadlineTask2.addToParameters(new Parameter(ParameterType.CATEGORY, "Functions"));
		expectedEntries.add(deadlineTask2);
		
		FileWriter addToFile = new FileWriter(testStorageFileForOpen);
		for (int i = 0; i < expectedEntries.size(); i++) {
			String entrydetails = expectedEntries.get(i).toString();
			addToFile.write(entrydetails);
			addToFile.write(System.lineSeparator());
			addToFile.flush();
		}
		addToFile.close();
		
		logic.processCommand("open testOpen");
	}
		
	@Test
	public void testResponsesForNew() {
		Response actualResponse = logic.processCommand("new testNew");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_CREATING_EXISTNG_FILE);
		testResponseEquality("test failure Response for creating file that already exists", expectedResponse,
				             actualResponse);
			
		actualResponse = logic.processCommand("new AcademicManager");		
		ArrayList<Entry> expectedEntriesForNew = new ArrayList<Entry>();
		String feedback = getFeedbackForSuccessfulLaunch("AcademicManager");
		expectedResponse = createSuccessResponse(feedback, expectedEntriesForNew);
		testResponseEquality("test success response for creating new file", expectedResponse, actualResponse);
		File storageFile = new File("AcademicManager" + ".str");
		storageFile.delete();
		File archiveFile = new File("AcademicManager" + ".arc");
		archiveFile.delete();
		File preferenceFile = new File("AcademicManager" + ".pref");
		preferenceFile.delete();
		
		logic.processCommand("open testOpen");
	}
	
	private String getFeedbackForSuccessfulLaunch(String fileName) {
		String feedback = MESSAGE_WELCOME.concat("<br>");
		feedback = feedback.concat(String.format(MESSAGE_FOR_FILENAME, fileName));
		
		return feedback;
	}
	
	@Test
	public void testResponsesForOpen() {
		Response actualResponse = logic.processCommand("open TaskManager");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_OPENING_NON_EXISTING_FILE);
		testResponseEquality("test failure response for opening file that does not exists", expectedResponse,
				             actualResponse);
		
		actualResponse = logic.processCommand("open testOpen");
		String feedback = getFeedbackForSuccessfulLaunch("testOpen");
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("test success response for opening existing file", expectedResponse, actualResponse);
	}
	
	@Test
	public void testResponsesForAdd() { 
		Response actualResponse = logic.processCommand("add ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("test failure response for not providing parameters after add command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("a Prepare for EE2020 Final Quiz pri ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_PRI_PARAMETER);
		testResponseEquality("test failure response for providing empty pri parameter", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("a Prepare for EE2020 Final Quiz pri H");
		Entry floatingTask = new Entry();
		floatingTask.addToParameters(new Parameter(ParameterType.INDEX, ""));
		floatingTask.addToParameters(new Parameter(ParameterType.NAME, "Prepare for EE2020 Final Quiz"));
		floatingTask.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		expectedEntries.add(floatingTask);
		updateSortingOfEntries(expectedEntries);
		String feedback = getFeedbackForSuccessfulAdd(floatingTask);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("test success response for adding floating task with priority", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_BY_PARAMETER);
		testResponseEquality("test failure response for providing empty by parameter", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by 10am");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_DATE);
		testResponseEquality("test failure response for not providing date", expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by 03/11/2015 10am");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
		testResponseEquality("test failure response for providing past date time", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by fri 10am cat ");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_CAT_PARAMETER);
		testResponseEquality("test failure response for providing empty cat parameter", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Submit MA3264 by fri 10am cat Mathematics");
		Entry deadlineTask = new Entry();
		deadlineTask.addToParameters(new Parameter(ParameterType.INDEX, ""));
		deadlineTask.addToParameters(new Parameter(ParameterType.NAME, "Submit MA3264"));
		deadlineTask.addToParameters(new Parameter(ParameterType.DATE, "06/11/2015"));
		deadlineTask.addToParameters(new Parameter(ParameterType.TIME, "10:00"));
		deadlineTask.addToParameters(new Parameter(ParameterType.CATEGORY, "Mathematics"));
		expectedEntries.add(deadlineTask);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulAdd(deadlineTask);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("test success response for adding deadline task with category", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_FROM_PARAMETER);
		testResponseEquality("test failure response for providing empty from parameter", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_END_DATE_TIME);
		testResponseEquality("test failure response for not providing end date time", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm to");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_EMPTY_TO_PARAMETER);
		testResponseEquality("test failure response for providing empty to parameter", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 1pm to 3pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_START_DATE);
		testResponseEquality("test failure response for not providing start date", expectedResponse, 
				             actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm to 12pm");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_PAST_DATE_TIME);
		testResponseEquality("test failure response for providing end date time earlier than start date time", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("add Final Exam from 27/11/2015 1pm to 3pm pri H cat EE2020");
		Entry event = new Entry();
		event.addToParameters(new Parameter(ParameterType.INDEX, ""));
		event.addToParameters(new Parameter(ParameterType.NAME, "Final Exam"));
		event.addToParameters(new Parameter(ParameterType.START_DATE, "27/11/2015"));
		event.addToParameters(new Parameter(ParameterType.START_TIME, "13:00"));
		event.addToParameters(new Parameter(ParameterType.END_DATE, "27/11/2015"));
		event.addToParameters(new Parameter(ParameterType.END_TIME, "15:00"));
		event.addToParameters(new Parameter(ParameterType.PRIORITY, "high"));
		event.addToParameters(new Parameter(ParameterType.CATEGORY, "EE2020"));
		expectedEntries.add(event);
		updateSortingOfEntries(expectedEntries);
		feedback = getFeedbackForSuccessfulAdd(event);
		expectedResponse = createSuccessResponse(feedback, expectedEntries);
		testResponseEquality("test success response for adding event with priority and category", 
			                 expectedResponse, actualResponse);
	}
	
	private void updateSortingOfEntries(ArrayList<Entry> entries) {
		Collections.sort(entries, new DateComparator());
		for (int i = 0; i < entries.size(); i++) {
			Entry entry = entries.get(i);
			Parameter indexParameter = new Parameter(ParameterType.INDEX, String.valueOf(i+1));
			entry.setIndexParameter(indexParameter);
		}
	}
	
	private String getFeedbackForSuccessfulAdd(Entry entry) {
		String feedback = MESSAGE_AFTER_ADD.concat("<br>").concat("<br>").concat(entry.toHTMLString());
		
		return feedback;
	}
	
	@Test
	public void testResponsesForEdit() {
		Response actualResponse = logic.processCommand("edit ");
		Response expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_PARAMETERS_AFTER_COMMAND);
		testResponseEquality("test failure response for not providing parameters after edit command", 
				             expectedResponse, actualResponse);
		
		actualResponse = logic.processCommand("edit 2");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_NO_EDITED_DETAILS);
		testResponseEquality("test failure response for not providing edited details", 
	                         expectedResponse, actualResponse);
	
		actualResponse = logic.processCommand("edit 5 Annual company dinner at Marina Mandarin");
		expectedResponse = createFailureResponse(MESSAGE_ERROR_FOR_INVALID_INDEX);
		testResponseEquality("test failure response for providing invalid index", expectedResponse, actualResponse);	
	}
	
	
	private String getFeedbackForSuccessfulEdit(Entry entryBeforeUpdate, Entry entryAfterUpdate) {
		String feedback = MESSAGE_AFTER_EDIT.concat("<br>").concat("<br>").concat(MESSAGE_FOR_UPDATED_ENTRY);
		feedback = feedback.concat("<br>").concat(entryAfterUpdate.toHTMLString());
		feedback = feedback.concat("<br>").concat(MESSAGE_FOR_OLD_ENTRY);
		feedback = feedback.concat("<br>").concat(entryBeforeUpdate.toHTMLString());
		
		return feedback;
	}
	
	private Response createSuccessResponse(String feedback, ArrayList<Entry> entries) {
		Response response = new Response();
		response.setIsSuccess(true);
		response.setFeedback(feedback);
		response.setEntries(entries);
		
		return response;
	}
	
	private Response createFailureResponse(String exMsg) {
		Response response = new Response();
		response.setIsSuccess(false);
		response.setFeedback(exMsg);
		
		return response;
	}
	
	private void testResponseEquality(String description, Response expectedResponse, Response actualResponse) {
		assertEquals(description, expectedResponse, actualResponse);
	}
	
	@After
	public void terminate() {
		testStorageFileForNew.delete();
		testArchiveFileForNew.delete();
		testPreferenceFileForNew.delete();
		testStorageFileForOpen.delete();
		testArchiveFileForOpen.delete();
		testPreferenceFileForOpen.delete();
	}
}
```
