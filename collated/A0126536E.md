# A0126536E
###### src\com\taskboard\main\command\BackgroundCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.awt.Image;

import javax.imageio.ImageIO;

import com.taskboard.main.tempstoragemanipulator.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class is responsible for executing the change background command. It recognizes 
 * both image file from a specified directory or an image URL from the internet.
 * @author Alvian Prasetya
 */
public class BackgroundCommand extends Command {

	private static final String MESSAGE_SET_BACKGROUND_SUCCESS = "Succesfully changed background image.";
	private static final String MESSAGE_SET_BACKGROUND_FAILURE = "The image format is not supported.";
	private static final String MESSAGE_FILE_NOT_FOUND = "The specified image does not exist.";
	
	private static final String STRING_USER_AGENT_ID = "User-Agent";
	private static final String STRING_USER_AGENT_CONTENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31";
	
	public BackgroundCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForBackground = new Response();
		
		assert (_parameters.size() == 1) : "Critical error: Background command parameter not found.";
		String imageFilePathString = _parameters.get(0).getParameterValue();
		File imageFilePath = new File(imageFilePathString);
		if (imageFilePath.exists() && !imageFilePath.isDirectory()) {
			// If the image is a file.
			try {
				UserInterface.getInstance().setBackgroundPath(imageFilePathString);
				_tempStorageManipulator.setBackgroundPath(imageFilePathString);
				responseForBackground.setIsSuccess(true);
				responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_SUCCESS);
			} catch (IOException e) {
				responseForBackground.setIsSuccess(false);
				responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_FAILURE);
			}
		} else {
			// If the image is not a file.
			try {
				// Checks if image is from a URL.
				URL imageURLPathString = new URL(imageFilePathString);
				final HttpURLConnection connection = (HttpURLConnection) imageURLPathString.openConnection();
				connection.setRequestProperty(
				    STRING_USER_AGENT_ID,
				    STRING_USER_AGENT_CONTENT);
				Image imageFileURL = ImageIO.read(connection.getInputStream());
				if (imageFileURL != null) {
					UserInterface.getInstance().setBackgroundPath(imageFilePathString);
					_tempStorageManipulator.setBackgroundPath(imageFilePathString);
					responseForBackground.setIsSuccess(true);
					responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_SUCCESS);
				} else {
					responseForBackground.setIsSuccess(false);
					responseForBackground.setFeedback(MESSAGE_FILE_NOT_FOUND);
				}
			} catch (MalformedURLException e) {
				responseForBackground.setIsSuccess(false);
				responseForBackground.setFeedback(MESSAGE_FILE_NOT_FOUND);
			} catch (IOException e) {
					responseForBackground.setIsSuccess(false);
					responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_FAILURE);
			}
		}
		
		return responseForBackground;
	}
	
}
```
###### src\com\taskboard\main\command\HelpCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;

import com.taskboard.main.tempstoragemanipulator.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class is responsible for forming the help message to be displayed to the user.
 * @author Alvian Prasetya
 */
public class HelpCommand extends Command {

	public HelpCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForHelp = new Response();
		ArrayList<Entry> helpList = new ArrayList<Entry>();
		
		for (int i = 0; i < 46; i++) {
			helpList.add(new Entry());
		}
		helpList.get(0).addToParameters(new Parameter(null, "<center><b>COMMAND</b></center>"));
		helpList.get(1).addToParameters(new Parameter(null, "<center><b>DESCRIPTION</b></center>"));
		
		helpList.get(2).addToParameters(new Parameter(null, "<b>add</b> NAME <b>by</b> DATE TIME"));
		helpList.get(3).addToParameters(new Parameter(null, "Add a deadline task"));
		
		helpList.get(4).addToParameters(new Parameter(null, "<b>add</b> NAME <b>from</b> DATE TIME <b>to</b> DATE TIME"));
		helpList.get(5).addToParameters(new Parameter(null, "Add an event"));
		
		helpList.get(6).addToParameters(new Parameter(null, "<b>add</b> NAME"));
		helpList.get(7).addToParameters(new Parameter(null, "Add a side task"));
		
		helpList.get(8).addToParameters(new Parameter(null, "<b>edit</b> INDEX SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(9).addToParameters(new Parameter(null, "Edit entry with specified index"));
		
		helpList.get(10).addToParameters(new Parameter(null, "<b>delete</b> INDEX"));
		helpList.get(11).addToParameters(new Parameter(null, "Delete entry with specified index"));
		
		helpList.get(12).addToParameters(new Parameter(null, "<b>delete</b> SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(13).addToParameters(new Parameter(null, "Delete entries that meet the specifications"));
		
		helpList.get(14).addToParameters(new Parameter(null, "<b>view</b> SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(15).addToParameters(new Parameter(null, "View entries that meet the specifications"));
		
		helpList.get(16).addToParameters(new Parameter(null, "<b>complete</b> INDEX"));
		helpList.get(17).addToParameters(new Parameter(null, "Mark entry with specified index as completed"));
		
		helpList.get(18).addToParameters(new Parameter(null, "<b>restore</b> INDEX"));
		helpList.get(19).addToParameters(new Parameter(null, "Restore entry with specified index from archive"));
		
		helpList.get(20).addToParameters(new Parameter(null, "<b>archive</b>"));
		helpList.get(21).addToParameters(new Parameter(null, "Display archived entries"));
		
		helpList.get(22).addToParameters(new Parameter(null, "<b>remind</b> NUM_OF_HOUR(S)"));
		helpList.get(23).addToParameters(new Parameter(null, "Set reminder to the specified number of hours"));
		
		helpList.get(24).addToParameters(new Parameter(null, "<b>background</b> IMAGE_FILE_PATH"));
		helpList.get(25).addToParameters(new Parameter(null, "Set the specified image file as background"));
		
		helpList.get(26).addToParameters(new Parameter(null, "<b>background</b> IMAGE_URL"));
		helpList.get(27).addToParameters(new Parameter(null, "Set the specified image URL as background"));
		
		helpList.get(28).addToParameters(new Parameter(null, "<b>command</b>"));
		helpList.get(29).addToParameters(new Parameter(null, "View TaskBoard's command list"));
		
		helpList.get(30).addToParameters(new Parameter(null, "<b>exit</b>"));
		helpList.get(31).addToParameters(new Parameter(null, "Quit the program"));
		
		helpList.get(32).addToParameters(new Parameter(null, ""));
		helpList.get(33).addToParameters(new Parameter(null, ""));
		
		helpList.get(34).addToParameters(new Parameter(null, "<center><b>SPECIFICATIONS</b></center>"));
		helpList.get(35).addToParameters(new Parameter(null, "<center><b>Delete, View, or Edit entries...</b></center>"));
		
		helpList.get(36).addToParameters(new Parameter(null, "<b>name</b>"));
		helpList.get(37).addToParameters(new Parameter(null, "which include the name"));
		
		helpList.get(38).addToParameters(new Parameter(null, "<b>by</b> DATE"));
		helpList.get(39).addToParameters(new Parameter(null, "of the specified date"));
		
		helpList.get(40).addToParameters(new Parameter(null, "<b>from</b> DATE <b>to</b> DATE"));
		helpList.get(41).addToParameters(new Parameter(null, "from and up to a specified date"));
		
		helpList.get(42).addToParameters(new Parameter(null, "<b>pri</b> PRIORITY_LEVEL"));
		helpList.get(43).addToParameters(new Parameter(null, "with the specified priority level"));
		
		helpList.get(44).addToParameters(new Parameter(null, "<b>cat</b> CATEGORY"));
		helpList.get(45).addToParameters(new Parameter(null, "with the specified category name"));
		
		responseForHelp.setIsSuccess(true);
		responseForHelp.setFeedback("Successfully displayed the list of commands.");
		responseForHelp.setEntries(helpList);
		
		return responseForHelp;
	}
	
}
```
###### src\com\taskboard\main\command\ReminderCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.IOException;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.tempstoragemanipulator.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class changes the value of the reminder hour that affects how many hours 
 * before UI displays the "SOON" label on an entry.
 * @author Alvian Prasetya
 */
public class ReminderCommand extends Command {
	
	private static final String MESSAGE_SET_REMINDER_SUCCESS = "Reminder succesfully set to %1$s hour(s).";
	private static final String MESSAGE_SET_REMINDER_FAILURE = "Reminder could not be set to %1$s hour(s).";
	
	public ReminderCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForReminder = new Response();
		
		assert (_parameters.size() == 1) : "Critical error: Reminder command parameter not found.";
		String reminderHourString = _parameters.get(0).getParameterValue();
		int reminderHour = Integer.parseInt(reminderHourString);
		
		if (reminderHour < 0) {
			responseForReminder.setIsSuccess(false);
			responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_FAILURE, reminderHourString));
		} else {
			UserInterface.getInstance().setReminderHour(reminderHour);
			try {
				_tempStorageManipulator.setReminderHour(reminderHour);
				responseForReminder.setIsSuccess(true);
				responseForReminder.setEntries(_tempStorageManipulator.getTempStorage());
				responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_SUCCESS, reminderHourString));
			} catch (IOException e) {
				responseForReminder.setIsSuccess(false);
				responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_FAILURE, reminderHourString));
			}
		}
		
		return responseForReminder;
	}
	
}
```
###### src\com\taskboard\main\command\UndoCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.IOException;

import com.taskboard.main.tempstoragemanipulator.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

/**
 * This class is responsible for executing the undo command. It swaps 
 * last checkpoint's TempStorage with the current TempStorage to simulate the undo 
 * effect. p.s.: Undo twice is equivalent to Redo.
 * @author Alvian Prasetya
 */
public class UndoCommand extends Command {
	
	private static final String MESSAGE_UNDO_SUCCESS = "Succesfully undo last operation.";
	private static final String MESSAGE_UNDO_FAILURE = "Undo failed: no previous checkpoint found.";
	
	public UndoCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForUndo = new Response();
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		ArrayList<Entry> lastTempStorage;
		if (_tempStorageManipulator.getLastTempStorage() != null) {
			System.out.println("INNNNN");
			lastTempStorage = new ArrayList<Entry>();
			for (Entry entry: _tempStorageManipulator.getLastTempStorage()) {
				lastTempStorage.add(new Entry(entry));
			}
		} else {
			lastTempStorage = null;
		}
		
		ArrayList<Entry> lastTempArchive;
		if (_tempStorageManipulator.getLastTempArchive() != null) {
			System.out.println("INNNNN");
			lastTempArchive = new ArrayList<Entry>();
			for (Entry entry: _tempStorageManipulator.getLastTempArchive()) {
				lastTempArchive.add(new Entry(entry));
			}
		} else {
			lastTempArchive = null;
		}
		
		if (lastTempStorage != null && lastTempArchive != null) {
			// Only updates the lastTempStorage & lastTempArchive upon successful execution.
			try {
				_tempStorageManipulator.setTempStorage(lastTempStorage);
				_tempStorageManipulator.setLastTempStorage(initialTempStorage);
				_tempStorageManipulator.setTempArchive(lastTempArchive);
				_tempStorageManipulator.setLastTempArchive(initialTempArchive);
				responseForUndo.setIsSuccess(true);
				responseForUndo.setFeedback(MESSAGE_UNDO_SUCCESS);
				responseForUndo.setEntries(lastTempStorage);
			} catch (IOException e) {
				responseForUndo.setIsSuccess(false);
				responseForUndo.setFeedback(MESSAGE_UNDO_FAILURE);
			}
		} else {
			responseForUndo.setIsSuccess(false);
			responseForUndo.setFeedback(MESSAGE_UNDO_FAILURE);
		}
		
		return responseForUndo;
	}
	
}
```
###### src\com\taskboard\main\formatvalidator\DateFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

import java.text.SimpleDateFormat;
import java.text.ParseException;

import java.util.Calendar;
import java.util.Date;

/**
 * This class validates a String if it's a valid date format 
 * and converts it to the default date format dd/MM/yyyy.
 * @author Alvian Prasetya
 */
public class DateFormatValidator implements FormatValidator {
	
	// constants
	
	private static final int MILLISECONDS_PER_DAY = 86400000;
	private static final int DAY_INDEX_MONDAY = 1;
	private static final int DAY_INDEX_TUESDAY = 2;
	private static final int DAY_INDEX_WEDNESDAY = 3;
	private static final int DAY_INDEX_THURSDAY = 4;
	private static final int DAY_INDEX_FRIDAY = 5;
	private static final int DAY_INDEX_SATURDAY = 6;
	private static final int DAY_INDEX_SUNDAY = 7;
	private static final String DEFAULT_DATE_FORMAT = "dd/MM/yyyy";
	// The list of supported date formats.
	private static final String[] DATE_FORMATS = {"d/MM/yyyy", 
												 "d/M/yyyy", 
												 "dd/MM/yyyy", 
												 "dd/M/yyyy", 
												 "d-MM-yyyy", 
												 "d-M-yyyy", 
												 "dd-MM-yyyy", 
												 "dd-M-yyyy", 
												 "d/MM", 
												 "d/M", 
												 "dd/MM", 
												 "dd/M", 
												 "d-MM", 
												 "d-M", 
												 "dd-MM", 
												 "dd-M", 
												 "d MMM", 
												 "dd MMM", 
												 "d MMMMM", 
												 "dd MMMMM", 
												 "d MMM yyyy", 
												 "dd MMM yyyy", 
												 "d MMMMM yyyy", 
												 "dd MMMMM yyyy"};
	
	// constructors
	
	public DateFormatValidator() {
		
	}
	
	// functionalities
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "tda" :
				// Fallthrough.
			case "today" :
				// Fallthrough.
			case "tomo" :
				// Fallthrough.
			case "tomorrow" :
				// Fallthrough.
			case "mon" :
				// Fallthrough.
			case "monday" :
				// Fallthrough.
			case "tue" :
				// Fallthrough.
			case "tuesday" :
				// Fallthrough.
			case "wed" :
				// Fallthrough.
			case "wednesday" :
				// Fallthrough.
			case "thu" :
				// Fallthrough.
			case "thursday" :
				// Fallthrough.
			case "fri" :
				// Fallthrough.
			case "friday" :
				// Fallthrough.
			case "sat" :
				// Fallthrough.
			case "saturday" :
				// Fallthrough.
			case "sun" :
				// Fallthrough.
			case "sunday" :
				return true;
			default :
				for (String currentDateFormat: DATE_FORMATS) {
					if (isMatchingDateFormat(new SimpleDateFormat(currentDateFormat), token)) {
						return true;
					}
				}
				return false;
		}
	}
	
	public String toDefaultFormat(String token) {
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
		defaultDateFormat.setLenient(false);
		Date today = new Date();
		
		token = token.toLowerCase();
		switch (token) {
			case "tda" :
				// Fallthrough.
			case "today" :
				return defaultDateFormat.format(today);
			case "tomo" :
				// Fallthrough.
			case "tomorrow" :
				Date tomorrow = new Date(today.getTime() + MILLISECONDS_PER_DAY);
				return defaultDateFormat.format(tomorrow);
			case "mon" :
				// Fallthrough.
			case "monday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_MONDAY));
			case "tue" :
				// Fallthrough.
			case "tuesday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_TUESDAY));
			case "wed" :
				// Fallthrough.
			case "wednesday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_WEDNESDAY));
			case "thu" :
				// Fallthrough.
			case "thursday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_THURSDAY));
			case "fri" :
				// Fallthrough.
			case "friday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_FRIDAY));
			case "sat" :
				// Fallthrough.
			case "saturday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_SATURDAY));
			case "sun" :
				// Fallthrough.
			case "sunday" :
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_SUNDAY));
			default :
				for (String currentDateFormat: DATE_FORMATS) {
					if (isMatchingDateFormat(new SimpleDateFormat(currentDateFormat), token)) {
						return toStandardDateFormat(new SimpleDateFormat(currentDateFormat), token);
					}
				}
				return null;
		}
	}
	
	private static Date getNextOccurenceDate(int dayIndex) {
		SimpleDateFormat dayIndexFormat = new SimpleDateFormat("u");
		dayIndexFormat.setLenient(false);
		Date today = new Date();
		int todayDayIndex = Integer.parseInt(dayIndexFormat.format(today));
		
		if (todayDayIndex < dayIndex) {
			Date target = new Date(today.getTime() + MILLISECONDS_PER_DAY * 
						  (dayIndex - todayDayIndex));
			assert (!today.after(target)); // today must be either before or the same day as target
			return target;
		} else {
			Date target = new Date(today.getTime() + MILLISECONDS_PER_DAY * 
					  	  (dayIndex - todayDayIndex + 7));
			assert (!today.after(target)); // today must be either before or the same day as target
			return target;
		}
	}
	
	private static boolean isMatchingDateFormat(SimpleDateFormat dateFormat, String input) {
		dateFormat.setLenient(false);
		try {
			String output = dateFormat.format(dateFormat.parse(input));
			if (output.equalsIgnoreCase(input)) {
				return true;
			} else {
				return false;
			}
		} catch (ParseException e) {
			return false;
		}
	}
	
	private static String toStandardDateFormat(SimpleDateFormat dateFormat, String input) {
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
		defaultDateFormat.setLenient(false);
		try {
			if (!dateFormat.toPattern().contains("y")) {
				Calendar currentDate = Calendar.getInstance();
				Calendar parsedDate = Calendar.getInstance();
				
				parsedDate.setTime(dateFormat.parse(input));
				parsedDate.set(Calendar.HOUR, 23);
				parsedDate.set(Calendar.MINUTE, 59);
				parsedDate.set(Calendar.YEAR, currentDate.get(Calendar.YEAR));
				
				if (parsedDate.before(currentDate)) {
					parsedDate.set(Calendar.YEAR, currentDate.get(Calendar.YEAR) + 1);
				}
				
				String output = defaultDateFormat.format(parsedDate.getTime());
				return output;
			} else {
				String output = defaultDateFormat.format(dateFormat.parse(input));
				return output;
			}
		} catch (ParseException e) {
			assert false: "Code should not be reached.";
			return null;
		}
	}
	
}
```
###### src\com\taskboard\main\formatvalidator\FormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

/**
 * This is an interface in which all format validating classes are implementing.
 * @author Alvian Prasetya
 */
public interface FormatValidator {

	public boolean isValidFormat(String token);
	public String toDefaultFormat(String token);
	
}
```
###### src\com\taskboard\main\formatvalidator\NumberFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

/**
 * This class validates a String if it is a valid number (integer).
 * @author ASUS
 */
public class NumberFormatValidator implements FormatValidator {
	
	public NumberFormatValidator() {
		
	}
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		if (isNumeric(token)) {
			return true;
		} else {
			return false;
		}
	}
	
	public static boolean isNumeric(String token) {
		try {
			Integer.parseInt(token);
		} catch (NumberFormatException nfe) {
			return false;
		}
		return true;
	}
	
	public String toDefaultFormat(String token) {
		return token;
	}
	
}
```
###### src\com\taskboard\main\formatvalidator\PriorityFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

/**
 * This class validates a String if it is of a supported priority format and 
 * converts it to the default priority format.
 * @author Alvian Prasetya
 */
public class PriorityFormatValidator implements FormatValidator {

	// constructors
	
	public PriorityFormatValidator() {
		
	}
	
	// functionalies
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "l" :
				// Fallthrough.
			case "lo" :
				// Fallthrough.
			case "low" :
				// Fallthrough.
			case "m" :
				// Fallthrough.
			case "med" :
				// Fallthrough.
			case "medium" :
				// Fallthrough.
			case "h" :
				// Fallthrough.
			case "hi" :
				// Fallthrough.
			case "high" :
				return true;
			default :
				return false;
		}
	}
	
	public String toDefaultFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "l" :
				// Fallthrough.
			case "lo" :
				// Fallthrough.
			case "low" :
				return new String("low");
			case "m" :
				// Fallthrough.
			case "med" :
				// Fallthrough.
			case "medium" :
				return new String("medium");
			case "h" :
				// Fallthrough.
			case "hi" :
				// Fallthrough.
			case "high" :
				return new String("high");
			default :
				return null;
		}
	}
	
}
```
###### src\com\taskboard\main\formatvalidator\TimeFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

/**
 * This class validates a String if it is of a supported time format and 
 * converts it to the default time format hh:mm.
 * @author Alvian Prasetya
 */
public class TimeFormatValidator implements FormatValidator {

	private static final String AM = "am";
	private static final String PM = "pm";
	private static final String COLON = ":";
	private static final String DOT = ".";
	
	public TimeFormatValidator() {
		
	}
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		if (token.indexOf(AM) == 1 && token.length() == 3) {
			return true;
		} else if (token.indexOf(AM) == 2 && token.length() == 4) {
			return true;
		} else if (token.indexOf(PM) == 1 && token.length() == 3) {
			return true;
		} else if (token.indexOf(PM) == 2 && token.length() == 4) {
			return true;
		} else if (token.indexOf(COLON) == 1 && token.length() == 4) {
			return true;
		} else if (token.indexOf(COLON) == 2 && token.length() == 5) {
			return true;
		} else if (token.indexOf(DOT) == 1 && token.length() == 4) {
			return true;
		} else if (token.indexOf(DOT) == 2 && token.length() == 5) {
			return true;
		} else {
			return false;
		}
	}
	
	public String toDefaultFormat(String token) {
		String hh = "";
		String mm = "";
		
		token = token.toLowerCase();
		if (token.indexOf(AM) == 1 && token.length() == 3) {
			hh = "0" + token.substring(0, token.indexOf(AM));
			// 12am is 00:00
			if (hh.equals("12")) {
				hh = "00";
			}
			mm = "00";
		} else if (token.indexOf(AM) == 2 && token.length() == 4) {
			hh = token.substring(0, token.indexOf(AM));
			// 12am is 00:00
			if (hh.equals("12")) {
				hh = "00";
			}
			mm = "00";
		} else if (token.indexOf(PM) == 1 && token.length() == 3) {
			hh = Integer.toString(Integer.parseInt(token.substring(0, token.indexOf(PM))) + 12);
			// 12pm is 12:00
			if (hh.equals("24")) {
				hh = "12";
			}
			mm = "00";
		} else if (token.indexOf(PM) == 2 && token.length() == 4) {
			hh = Integer.toString(Integer.parseInt(token.substring(0, token.indexOf(PM))) + 12);
			// 12pm is 12:00
			if (hh.equals("24")) {
				hh = "12";
			}
			mm = "00";
		} else if (token.indexOf(COLON) == 1 && token.length() == 4) {
			hh = "0" + token.substring(0, token.indexOf(COLON));
			mm = token.substring(token.indexOf(COLON) + 1);
		} else if (token.indexOf(COLON) == 2 && token.length() == 5) {
			hh = token.substring(0, token.indexOf(COLON));
			mm = token.substring(token.indexOf(COLON) + 1);
		} else if (token.indexOf(DOT) == 1 && token.length() == 4) {
			hh = "0" + token.substring(0, token.indexOf(DOT));
			mm = token.substring(token.indexOf(DOT) + 1);
		} else if (token.indexOf(DOT) == 2 && token.length() == 5) {
			hh = token.substring(0, token.indexOf(DOT));
			mm = token.substring(token.indexOf(DOT) + 1);
		} else {
			assert false: "Found a foreign case for time validator.";
		}
		
		return hh + COLON + mm;
	}
	
}
```
###### src\com\taskboard\main\logger\GlobalLogger.java
``` java
package com.taskboard.main.logger;

import java.io.IOException;

import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.Date;

import java.text.SimpleDateFormat;

/**
 * This is a class used as a global logger singleton to write logs into file based on time 
 * of execution.
 * @author Alvian Prasetya
 */
public class GlobalLogger {
	
	private static final String logDirectory = "logs/";
	private static final String logFileName = new SimpleDateFormat("dd-MM-yyyy_hh.mm.ss").format(new Date());
	private static final String logFileFormat = ".log";
	
	private static GlobalLogger _instance = null;
	private static Logger _logger;
	private static FileHandler _loggerFileHandler;
	private static SimpleFormatter _loggerFormatter;
	
	private GlobalLogger() {
		try {
			_loggerFileHandler = new FileHandler(logDirectory + logFileName + logFileFormat, true);
		} catch (IOException exception) {
			// TBA: process exception or throw exception
		}
		_loggerFormatter = new SimpleFormatter();
		_loggerFileHandler.setFormatter(_loggerFormatter);
		_logger = Logger.getLogger(logFileName);
		_logger.addHandler(_loggerFileHandler);
	}
	
	public static GlobalLogger getInstance() {
		if (_instance == null) {
			_instance = new GlobalLogger();
		}
		return _instance;
	}
	
	public Logger getLogger() {
		return _logger;
	}
	
}
```
###### src\com\taskboard\main\parser\AddParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This class is an implementation of ParameterParser and is used to parse an 
 * ADD command string into its parameters.
 * @author Alvian Prasetya
 */
public class AddParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	private static final String MESSAGE_NO_ENTRY_NAME = "No entry name provided.";
	private static final String MESSAGE_EMPTY_PARAMETER = "Empty %1$s parameter provided.";
	
	private Logger _logger;
	
	public AddParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no entry name, no parameters, or empty parameter.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of ADD command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.add(new Parameter(ParameterType.NAME, parameterString));
		} else {
			parameters.addAll(extractParameters(delimiterTypes, parameterString));
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of ADD command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		if (!isParameterExists(parameters, ParameterType.NAME)) {
			throw new IllegalArgumentException(MESSAGE_NO_ENTRY_NAME);
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static ArrayList<Parameter> extractParameters(ArrayList<DelimiterType> delimiterTypes, 
														  String parameterString) throws IllegalArgumentException {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		int expectedDelimiterId = 0;
		DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
		String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
		
		String temporaryString = STRING_EMPTY;
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
				if (temporaryString.isEmpty()) {
					throw new IllegalArgumentException(String.format(MESSAGE_EMPTY_PARAMETER, expectedDelimiterName));
				} else {
					ArrayList<Parameter> parametersToAdd = convertToParameters(reverseTokens(temporaryString), expectedDelimiterType);
					if (parametersToAdd.isEmpty()) {
						temporaryString += STRING_SPACE + tokens[i];
					} else {
						parameters.addAll(parametersToAdd);
						temporaryString = STRING_EMPTY;
					}
				}
				
				expectedDelimiterId++;
				if (expectedDelimiterId < delimiterTypes.size()) {
					expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
					expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
				} else {
					expectedDelimiterType = null;
					expectedDelimiterName = STRING_EMPTY; // name does not have delimiter
				}
			} else {
				temporaryString += STRING_SPACE + tokens[i];
			}
		}
		if (!temporaryString.isEmpty()) {
			parameters.add(new Parameter(ParameterType.NAME, reverseTokens(temporaryString)));
		}
		
		return parameters;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = STRING_EMPTY;
		
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + STRING_SPACE;
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		switch (delimiterType) {
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString));
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString));
				break;
			default:
				break;
		}
		
		return parameters;
	}
	
	private boolean isParameterExists(ArrayList<Parameter> parameters, ParameterType parameterType) {
		for (Parameter currentParameter: parameters) {
			if (currentParameter.getParameterType() == parameterType) {
				return true;
			}
		}
		return false;
	}
	
}
```
###### src\com\taskboard\main\parser\BackgroundParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * BACKGROUND command string into its parameters.
 * @author Alvian Prasetya
 */
public class BackgroundParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	
	private Logger _logger;
	
	public BackgroundParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no parameters provided.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of BACKGROUND command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		parameters.add(new Parameter(ParameterType.NAME, parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of BACKGROUND command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\parser\CommandParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.command.AddCommand;
import com.taskboard.main.command.ArchiveCommand;
import com.taskboard.main.command.BackgroundCommand;
import com.taskboard.main.command.Command;
import com.taskboard.main.command.CompleteCommand;
import com.taskboard.main.command.DeleteCommand;
import com.taskboard.main.command.EditCommand;
import com.taskboard.main.command.HelpCommand;
import com.taskboard.main.command.InvalidCommand;
import com.taskboard.main.command.NewCommand;
import com.taskboard.main.command.OpenCommand;
import com.taskboard.main.command.ReminderCommand;
import com.taskboard.main.command.RestoreCommand;
import com.taskboard.main.command.UndoCommand;
import com.taskboard.main.command.ViewCommand;
import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.CommandType;
import com.taskboard.main.util.Parameter;

/**
 * This class is a facade class that is used to parse a command string into 
 * a Command object containing CommandType and ArrayList of Parameters.
 * @author Alvian Prasetya
 */
public class CommandParser {
	
	private CommandTypeParser _commandTypeParser;
	private ParameterParser _parameterParser;
	private Logger _logger;
	
	public CommandParser() {
		_commandTypeParser = new CommandTypeParser();
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Command parseCommand(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing command string: " + commandString);
		CommandType newCommandType = _commandTypeParser.parseCommandType(commandString);
		switch (newCommandType) {
			case NEW:
				_parameterParser = new OpenParameterParser();
				ArrayList<Parameter> newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing NEW command string");
				return new NewCommand(newCommandParameters);
			case OPEN:
				_parameterParser = new OpenParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing OPEN command string");
				return new OpenCommand(newCommandParameters);
			case ADD:
				_parameterParser = new AddParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing ADD command string");
				return new AddCommand(newCommandParameters);
			case EDIT:
				_parameterParser = new EditParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing EDIT command string");
				return new EditCommand(newCommandParameters);
			case DELETE:
				_parameterParser = new DeleteParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing DELETE command string");
				return new DeleteCommand(newCommandParameters);
			case VIEW:
				_parameterParser = new ViewParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing VIEW command string");
				return new ViewCommand(newCommandParameters);
			case COMPLETE:
				_parameterParser = new CompleteParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing COMPLETE command string");
				return new CompleteCommand(newCommandParameters);
			case RESTORE:
				_parameterParser = new RestoreParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing RESTORE command string");
				return new RestoreCommand(newCommandParameters);
			case ARCHIVE:
				_logger.log(Level.INFO, "Finished parsing ARCHIVE command string");
				return new ArchiveCommand(null);
			case UNDO:
				_logger.log(Level.INFO, "Finished parsing UNDO command string");
				return new UndoCommand(null);
			case BACKGROUND:
				_parameterParser = new BackgroundParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing BACKGROUND command string");
				return new BackgroundCommand(newCommandParameters);
			case REMINDER:
				_parameterParser = new ReminderParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing REMINDER command string");
				return new ReminderCommand(newCommandParameters);
			case HELP:
				_logger.log(Level.INFO, "Finished parsing HELP command string");
				return new HelpCommand(null);
			case UNKNOWN:
				_logger.log(Level.INFO, "Finished parsing UNKNOWN command string");
				return new InvalidCommand(null);
			default:
				_logger.log(Level.SEVERE, "Unexpected execution of unreachable code in CommandParser");
				assert false : "Unexpected execution of unreachable code";
				return null;
		}
	}
	
}
```
###### src\com\taskboard\main\parser\CommandTypeParser.java
``` java
package com.taskboard.main.parser;

import com.taskboard.main.util.CommandType;

/**
 * This class is used to parse a command string into its respective CommandType.
 * @author Alvian Prasetya
 */
public class CommandTypeParser {
	
	private static final String STRING_SPACE = " ";
	
	public CommandTypeParser() {
		
	}
	
	public CommandType parseCommandType(String commandString) {
		String commandTypeString = extractCommandTypeString(commandString).toLowerCase();
		
		switch (commandTypeString) {
			case "a" :
				// Fallthrough.
			case "add" :
				return CommandType.ADD;
			case "e" :
				// Fallthrough.
			case "edit" :
				return CommandType.EDIT;
			case "d" :
				// Fallthrough.
			case "delete" :
				return CommandType.DELETE;
			case "v" :
				// Fallthrough.
			case "view" :
				return CommandType.VIEW;
			case "o" :
				// Fallthrough.
			case "open" :
				return CommandType.OPEN;
			case "n" :
				// Fallthrough.
			case "new" :
				return CommandType.NEW;
			case "done" :
				// Fallthrough.
			case "c" :
				// Fallthrough.
			case "check" :
				// Fallthrough.
			case "complete" :
				return CommandType.COMPLETE;
			case "r" :
				// Fallthrough.
			case "restore" :
				// Fallthrough.
			case "revert" :
				return CommandType.RESTORE;
			case "arc" :
				// Fallthrough.
			case "arch" :
				// Fallthrough.
			case "archive" :
				return CommandType.ARCHIVE;
			case "undo" :
				// Fallthrough.
			case "un" :
				// Fallthrough.
			case "u" :
				return CommandType.UNDO;
			case "background" :
				// Fallthrough.
			case "bg" :
				return CommandType.BACKGROUND;
			case "reminder" :
				// Fallthrough.
			case "remind" :
				return CommandType.REMINDER;
			case "h" :
				// Fallthrough.
			case "help" :
				// Fallthrough.
			case "cmd" :
				// Fallthrough.
			case "command" :
				// Fallthrough.
			case "commands":
				return CommandType.HELP;
			case "esc" :
				// Fallthrough.
			case "exit":
				return CommandType.EXIT;
			default:
				return CommandType.UNKNOWN;
		}
	}
	
	public static String extractCommandTypeString(String commandString) {
		if (commandString.indexOf(STRING_SPACE) == -1) {
			return commandString;
		} else {
			return commandString.substring(0, commandString.indexOf(STRING_SPACE)).toLowerCase();
		}
	}
	
}
```
###### src\com\taskboard\main\parser\CompleteParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.Parameter;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * COMPLETE command string into its parameters.
 * @author Alvian Prasetya
 */
public class CompleteParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	
	private Logger _logger;
	
	public CompleteParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no index provided.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of COMPLETE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		parameters.add(ParameterParser.getIndex(parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of COMPLETE command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\parser\DeleteParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * DELETE command string into its parameters.
 * @author Alvian Prasetya
 */
public class DeleteParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	private static final String MESSAGE_EMPTY_PARAMETER = "Empty %1$s parameter provided.";
	
	private Logger _logger;
	
	public DeleteParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no parameters or empty parameter.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of DELETE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.addAll(convertToParameters(parameterString, DelimiterType.NONE));
		} else {
			parameters.addAll(extractParameters(delimiterTypes, parameterString));
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of DELETE command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static ArrayList<Parameter> extractParameters(ArrayList<DelimiterType> delimiterTypes, 
														  String parameterString) throws IllegalArgumentException {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		int expectedDelimiterId = 0;
		DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
		String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
		
		String temporaryString = STRING_EMPTY;
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
				if (temporaryString.isEmpty()) {
					throw new IllegalArgumentException(String.format(MESSAGE_EMPTY_PARAMETER, expectedDelimiterName));
				} else {
					ArrayList<Parameter> parametersToAdd = convertToParameters(reverseTokens(temporaryString), expectedDelimiterType);
					if (parametersToAdd.isEmpty()) {
						temporaryString += STRING_SPACE + tokens[i];
					} else {
						parameters.addAll(parametersToAdd);
						temporaryString = STRING_EMPTY;
					}
				}
				
				expectedDelimiterId++;
				if (expectedDelimiterId < delimiterTypes.size()) {
					expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
					expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
				} else {
					expectedDelimiterType = null;
					expectedDelimiterName = STRING_EMPTY; // name does not have delimiter
				}
			} else {
				temporaryString += STRING_SPACE + tokens[i];
			}
		}
		if (!temporaryString.isEmpty()) {
			parameters.addAll(convertToParameters(reverseTokens(temporaryString), DelimiterType.NONE));
		}
		
		return parameters;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = STRING_EMPTY;
		
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + STRING_SPACE;
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		switch (delimiterType) {
			case NONE:
				parameters.add(ParameterParser.getIndex(parameterString));
				break;
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString));
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString));
				break;
			default:
				break;
		}
		
		return parameters;
	}

}
```
###### src\com\taskboard\main\parser\EditParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This class is an implementation of ParameterParser and is used to parse an 
 * EDIT command string into its parameters.
 * @author Alvian Prasetya
 */
public class EditParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	private static final String MESSAGE_NO_EDITED_DETAILS = "No edited details provided.";
	private static final String MESSAGE_EMPTY_PARAMETER = "Empty %1$s parameter provided.";
	private static final String MESSAGE_NO_INDEX = "No entry index provided.";
	
	private Logger _logger;
	
	public EditParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no entry index, no parameters, or empty parameter.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of EDIT command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		if (parameterString.trim().indexOf(STRING_SPACE) != -1) {
			String indexString = parameterString.substring(0, parameterString.indexOf(STRING_SPACE)).trim();
			
			Parameter indexParameter = ParameterParser.getIndex(indexString);
			parameters.add(indexParameter);
			
			parameterString = parameterString.substring(parameterString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_EDITED_DETAILS);
		}
		
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.addAll(convertToParameters(parameterString, DelimiterType.NONE));
		} else {
			parameters.addAll(extractParameters(delimiterTypes, parameterString));
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of EDIT command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		if (!isParameterExists(parameters, ParameterType.INDEX)) {
			throw new IllegalArgumentException(MESSAGE_NO_INDEX);
		}
		
		return parameters;
	}

	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();

		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}

		return delimiterTypes;
	}
	
	private static ArrayList<Parameter> extractParameters(ArrayList<DelimiterType> delimiterTypes, 
														  String parameterString) throws IllegalArgumentException {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		int expectedDelimiterId = 0;
		DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
		String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();

		String temporaryString = STRING_EMPTY;
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
				if (temporaryString.isEmpty()) {
					throw new IllegalArgumentException(String.format(MESSAGE_EMPTY_PARAMETER, expectedDelimiterName));
				} else {
					ArrayList<Parameter> parametersToAdd = convertToParameters(reverseTokens(temporaryString), expectedDelimiterType);
					if (parametersToAdd.isEmpty()) {
						temporaryString += STRING_SPACE + tokens[i];
					} else {
						parameters.addAll(parametersToAdd);
						temporaryString = STRING_EMPTY;
					}
				}

				expectedDelimiterId++;
				if (expectedDelimiterId < delimiterTypes.size()) {
					expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
					expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
				} else {
					expectedDelimiterType = null;
					expectedDelimiterName = STRING_EMPTY; // name does not have delimiter
				}
			} else {
				temporaryString += STRING_SPACE + tokens[i];
			}
		}
		if (!temporaryString.isEmpty()) {
			parameters.addAll(convertToParameters(reverseTokens(temporaryString), DelimiterType.NONE));
		}
		
		return parameters;
	}
		
	private static String reverseTokens(String parameterString) {
		String resultString = STRING_EMPTY;

		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + STRING_SPACE;
		}

		return resultString.trim();
	}

	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		switch (delimiterType) {
			case NONE:
				parameters.add(ParameterParser.getNewName(parameterString));
				break;
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString));
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString));
				break;
			default:
				break;
		}

		return parameters;
	}
	
	private boolean isParameterExists(ArrayList<Parameter> parameters, ParameterType parameterType) {
		for (Parameter currentParameter: parameters) {
			if (currentParameter.getParameterType() == parameterType) {
				return true;
			}
		}
		return false;
	}

}
```
###### src\com\taskboard\main\parser\OpenParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This class is an implementation of ParameterParser and is used to parse an 
 * OPEN command string into its parameters.
 * @author Alvian Prasetya
 */
public class OpenParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	
	private Logger _logger;
	
	public OpenParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no parameters provided.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of OPEN command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		parameters.add(new Parameter(ParameterType.NAME, parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of OPEN command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\parser\ParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;

import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.formatvalidator.DateFormatValidator;
import com.taskboard.main.formatvalidator.TimeFormatValidator;
import com.taskboard.main.formatvalidator.PriorityFormatValidator;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This is an interface used to parse Parameters from a command string.
 * Will be implemented through various classes depending on the CommandType.
 * @author Alvian Prasetya
 */
public interface ParameterParser {
	
	static final String STRING_EMPTY = "";
	static final String STRING_SPACE = " ";
	static final String MESSAGE_INVALID_NUMERIC_FORMAT = "Invalid numeric format provided for index.";
	static final String MESSAGE_INVALID_PRIORITY_FORMAT = "Invalid priority format provided.";
	
	public ArrayList<Parameter> parseParameters(String commandString);
	
	static Parameter getIndex(String parameterString) throws IllegalArgumentException {
		FormatValidator numberFormatValidator = new NumberFormatValidator();
		String trimmedParameterString = parameterString.trim();
		if (trimmedParameterString.split(STRING_SPACE).length == 1) {
			if (numberFormatValidator.isValidFormat(parameterString)) {
				String index = numberFormatValidator.toDefaultFormat(parameterString);
				return new Parameter(ParameterType.INDEX, index);
			} else {
				throw new IllegalArgumentException(MESSAGE_INVALID_NUMERIC_FORMAT);
			}
		} else {
			throw new IllegalArgumentException(MESSAGE_INVALID_NUMERIC_FORMAT);
		}
	}
	
	static Parameter getNewName(String parameterString) {
		return new Parameter(ParameterType.NEW_NAME, parameterString);
	}
	
	static ArrayList<Parameter> getStartDateTime(String parameterString) {
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		ArrayList<Parameter> startDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(STRING_SPACE);
		String compoundToken = STRING_EMPTY;
		
		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + STRING_SPACE + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String startDate = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				startDateTime.add(new Parameter(ParameterType.START_DATE, startDate));
				compoundToken = STRING_EMPTY;
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String startDate = dateFormatValidator.toDefaultFormat(compoundToken);
				startDateTime.add(new Parameter(ParameterType.START_DATE, startDate));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String startTime = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				startDateTime.add(new Parameter(ParameterType.START_TIME, startTime));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String startTime = timeFormatValidator.toDefaultFormat(compoundToken);
				startDateTime.add(new Parameter(ParameterType.START_TIME, startTime));
				compoundToken = STRING_EMPTY;
			}
		}

		return startDateTime;
	}

	static ArrayList<Parameter> getEndDateTime(String parameterString) {
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		ArrayList<Parameter> endDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(STRING_SPACE);
		String compoundToken = STRING_EMPTY;

		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + STRING_SPACE + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String endDate = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				endDateTime.add(new Parameter(ParameterType.END_DATE, endDate));
				compoundToken = STRING_EMPTY;
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String endDate = dateFormatValidator.toDefaultFormat(compoundToken);
				endDateTime.add(new Parameter(ParameterType.END_DATE, endDate));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String endTime = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				endDateTime.add(new Parameter(ParameterType.END_TIME, endTime));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String endTime = timeFormatValidator.toDefaultFormat(compoundToken);
				endDateTime.add(new Parameter(ParameterType.END_TIME, endTime));
				compoundToken = STRING_EMPTY;
			}
		}

		return endDateTime;
	}

	static ArrayList<Parameter> getDueDateTime(String parameterString) {
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		ArrayList<Parameter> dueDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(STRING_SPACE);
		String compoundToken = STRING_EMPTY;

		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + STRING_SPACE + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String date = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				dueDateTime.add(new Parameter(ParameterType.DATE, date));
				compoundToken = STRING_EMPTY;
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String date = dateFormatValidator.toDefaultFormat(compoundToken);
				dueDateTime.add(new Parameter(ParameterType.DATE, date));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String time = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				dueDateTime.add(new Parameter(ParameterType.TIME, time));
				compoundToken = STRING_EMPTY;
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String time = timeFormatValidator.toDefaultFormat(compoundToken);
				dueDateTime.add(new Parameter(ParameterType.TIME, time));
				compoundToken = STRING_EMPTY;
			}
		}
		
		return dueDateTime;
	}

	static Parameter getCategory(String parameterString) {
		String trimmedParameterString = parameterString.trim();
		return new Parameter(ParameterType.CATEGORY, trimmedParameterString);
	}

	static Parameter getPriority(String parameterString) throws IllegalArgumentException {
		FormatValidator priorityFormatValidator = new PriorityFormatValidator();
		String trimmedParameterString = parameterString.trim();
		if (trimmedParameterString.split(STRING_SPACE).length == 1) {
			if (priorityFormatValidator.isValidFormat(trimmedParameterString)) {
				String priority = priorityFormatValidator.toDefaultFormat(trimmedParameterString);
				return new Parameter(ParameterType.PRIORITY, priority);
			} else {
				throw new IllegalArgumentException(MESSAGE_INVALID_PRIORITY_FORMAT);
			}
		} else {
			throw new IllegalArgumentException(MESSAGE_INVALID_PRIORITY_FORMAT);
		}
	}
	
}

```
###### src\com\taskboard\main\parser\ReminderParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.Parameter;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * REMINDER command string into its parameters.
 * @author Alvian Prasetya
 */
public class ReminderParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	
	private Logger _logger;
	
	public ReminderParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no index provided.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of REMINDER command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		parameters.add(ParameterParser.getIndex(parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of REMINDER command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\parser\RestoreParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.Parameter;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * RESTORE command string into its parameters.
 * @author Alvian Prasetya
 */
public class RestoreParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_NO_PARAMETERS = "No parameters provided.";
	
	private Logger _logger;
	
	public RestoreParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no index provided.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of RESTORE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			throw new IllegalArgumentException(MESSAGE_NO_PARAMETERS);
		}
		
		parameters.add(ParameterParser.getIndex(parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of RESTORE command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\parser\ViewParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.logger.GlobalLogger;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This class is an implementation of ParameterParser and is used to parse a 
 * VIEW command string into its parameters.
 * @author Alvian Prasetya
 */
public class ViewParameterParser implements ParameterParser {
	
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	private static final String MESSAGE_EMPTY_PARAMETER = "Empty %1$s parameter provided.";
	
	private Logger _logger;
	
	public ViewParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	/**
	 * Returns a list of parameters from a command string.
	 * 
	 * @param commandString		The command string to be parsed into parameters.
	 * @return					ArrayList of parsed parameters.
	 * @throws IllegalArgumentException		If no parameters or empty parameter.
	 */
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of VIEW command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = STRING_EMPTY;
		if (commandString.trim().indexOf(STRING_SPACE) != -1) {
			parameterString = commandString.substring(commandString.indexOf(STRING_SPACE)).trim();
		} else {
			// view command allows a command with no trailing parameter (return an empty ArrayList)
			return parameters;
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.add(new Parameter(ParameterType.NAME, parameterString));
		} else {
			parameters.addAll(extractParameters(delimiterTypes, parameterString));
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of VIEW command");
		_logger.log(Level.INFO, "Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static ArrayList<Parameter> extractParameters(ArrayList<DelimiterType> delimiterTypes, 
														  String parameterString) throws IllegalArgumentException {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		int expectedDelimiterId = 0;
		DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
		String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
		
		String temporaryString = STRING_EMPTY;
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
				if (temporaryString.isEmpty()) {
					throw new IllegalArgumentException(String.format(MESSAGE_EMPTY_PARAMETER, expectedDelimiterName));
				} else {
					ArrayList<Parameter> parametersToAdd = convertToParameters(reverseTokens(temporaryString), expectedDelimiterType);
					if (parametersToAdd.isEmpty()) {
						temporaryString += STRING_SPACE + tokens[i];
					} else {
						parameters.addAll(parametersToAdd);
						temporaryString = STRING_EMPTY;
					}
				}
				
				expectedDelimiterId++;
				if (expectedDelimiterId < delimiterTypes.size()) {
					expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
					expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
				} else {
					expectedDelimiterType = null;
					expectedDelimiterName = STRING_EMPTY; // name does not have delimiter
				}
			} else {
				temporaryString += STRING_SPACE + tokens[i];
			}
		}
		if (!temporaryString.isEmpty()) {
			temporaryString = reverseTokens(temporaryString);
			parameters.add(new Parameter(ParameterType.NAME, temporaryString));
		}
		
		return parameters;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = STRING_EMPTY;
		
		String[] tokens = parameterString.split(STRING_SPACE);
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + STRING_SPACE;
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		
		switch (delimiterType) {
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString));
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString));
				break;
			default:
				break;
		}
		
		return parameters;
	}
	
}
```
###### src\com\taskboard\main\userinterface\BlinkingLabel.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.*;

import javax.swing.*;
import javax.swing.Timer;

public class BlinkingLabel extends JLabel {
	
	private static final long serialVersionUID = 5;
	private static final int DEFAULT_BLINK_RATE = 500;

	private int _blinkRate;
	private boolean _isBlinking;

	public BlinkingLabel() {
		super();
		_blinkRate = DEFAULT_BLINK_RATE;
		_isBlinking = true;
		Timer timer = new Timer(_blinkRate, new TimerListener(this));
		timer.setInitialDelay(0);
		timer.start();
	}

	public void setBlinking(boolean flag) {
		_isBlinking = flag;
	}
	public boolean isBlinking() {
		return _isBlinking;
	}

	private class TimerListener implements ActionListener {
		private BlinkingLabel bl;
		private boolean isVisible = true;

		public TimerListener(BlinkingLabel bl) {
			this.bl = bl;
		}

		public void actionPerformed(ActionEvent e) {
			if (bl.isBlinking()) {
				if (isVisible) {
					bl.setVisible(true);
				}
				else {
					bl.setVisible(false);
				}
				isVisible = !isVisible;
			}
			else {
				// Make sure that the label is visible if the blinking is off.
				if (isVisible) {
					bl.setVisible(true);
					isVisible = false;
				}
			}
		}

	}
	
}
```
###### src\com\taskboard\main\userinterface\ShortcutListener.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.util.ArrayList;

public class ShortcutListener implements KeyListener {
	private static final String EXIT_COMMAND_STRING = "exit";
	private static final String HELP_COMMAND_STRING = "help";
	private static final String UNDO_COMMAND_STRING = "undo";
	
	final ArrayList<Integer> pressed = new ArrayList<Integer>();
	
	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub  
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		if (arg0.getKeyCode() == KeyEvent.VK_CONTROL) {
			pressed.remove(new Integer(KeyEvent.VK_CONTROL));
		}
	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		if (arg0.getKeyCode() == KeyEvent.VK_ENTER) {
			if (!UserInterface.getInstance().getCommandField().getText().isEmpty()) {
				UserInterface.getInstance().executeInputCommand();
			}
		} else if (arg0.getKeyCode() == KeyEvent.VK_CONTROL) {
			pressed.add(new Integer(KeyEvent.VK_CONTROL));
		} else if (pressed.contains(new Integer(KeyEvent.VK_CONTROL))) {
			if (arg0.getKeyCode() == KeyEvent.VK_Z) {
				UserInterface.getInstance().getCommandField().setText(UNDO_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
				pressed.remove(new Integer(KeyEvent.VK_CONTROL));
			} else if (arg0.getKeyCode() == KeyEvent.VK_Q) {
				UserInterface.getInstance().getCommandField().setText(EXIT_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
				pressed.remove(new Integer(KeyEvent.VK_CONTROL));
			} else if (arg0.getKeyCode() == KeyEvent.VK_H) {
				UserInterface.getInstance().getCommandField().setText(HELP_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
				pressed.remove(new Integer(KeyEvent.VK_CONTROL));
			}
		}
	}
}
```
###### src\com\taskboard\main\userinterface\WindowResizeListener.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.io.IOException;

import javax.swing.JTextPane;

public class WindowResizeListener extends ComponentAdapter {
	// whenever the window is resized
	@Override
	public void componentResized(ComponentEvent frameResized) {
		try {
			UserInterface.getInstance().updateBackground();
		} catch (IOException e) {
			JTextPane feedbackArea = UserInterface.getInstance().getFeedbackArea();
			if (feedbackArea == null) {
				UserInterface.getInstance().setFeedbackArea(new JTextPane());
			}
			feedbackArea.setText("Unexpected error during background resize.");
		}
	}
}
```
###### src\com\taskboard\main\util\CommandType.java
``` java
package com.taskboard.main.util;

public enum CommandType {
	ADD, EDIT, DELETE, VIEW, OPEN, NEW, COMPLETE, RESTORE, ARCHIVE, 
	UNDO, BACKGROUND, REMINDER, HELP, EXIT, UNKNOWN;
}
```
###### src\com\taskboard\main\util\DelimiterType.java
``` java
package com.taskboard.main.util;

public enum DelimiterType {
	FROM, TO, BY, AT, ON, EVERY, CAT, PRI, NONE;
}
```
###### src\com\taskboard\main\util\Entry.java
``` java
package com.taskboard.main.util;

import java.util.ArrayList;

/**
 * This class is used as a container class comprising of parameters in an entry.
 * @author Alvian Prasetya
 */
public class Entry {
	
	private static final String STRING_NAME = "NAME";
	private static final String STRING_DATE = "DATE";
	private static final String STRING_TIME = "TIME";
	private static final String STRING_START_DATE = "START_DATE";
	private static final String STRING_START_TIME = "START_TIME";
	private static final String STRING_END_DATE = "END_DATE";
	private static final String STRING_END_TIME = "END_TIME";
	
	// attribute
	
	private ArrayList<Parameter> _parameters;
	
	// constructor
	
	public Entry() {
		_parameters = new ArrayList<Parameter>();
	}
	
	public Entry(Entry oldEntry) {
		_parameters = new ArrayList<Parameter>();
		for (Parameter currentParameter: oldEntry.getParameters()) {
			_parameters.add(new Parameter(currentParameter));
		}
	}
	
	public Entry(ArrayList<Parameter> parameters) {
		_parameters = parameters;
	}
	
	// accessors
	
	public ArrayList<Parameter> getParameters() {
		return _parameters;
	}
	
	public Parameter getIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getPriorityParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getCategoryParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	// mutators
	
	public void setParameters(ArrayList<Parameter> newParameters) {
		_parameters = newParameters;
	}
	
	public void addToParameters(Parameter newParameter) {
		_parameters.add(newParameter);
	}
	
	public void setIndexParameter(Parameter newIndexParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.set(i, newIndexParameter);
			}
		}
	}
	
	public void setNameParameter(Parameter newNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				_parameters.set(i, newNameParameter);
			}
		}
	}

	public void setDateParameter(Parameter newDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				_parameters.set(i, newDateParameter);
			}
		}
	}
	
	public void setTimeParameter(Parameter newTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				_parameters.set(i, newTimeParameter);
			}
		}
	}
	
	public void setStartDateParameter(Parameter newStartDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				_parameters.set(i, newStartDateParameter);
			}
		}
	}
	
	public void setStartTimeParameter(Parameter newStartTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				_parameters.set(i, newStartTimeParameter);
			}
		}
	}
	
	public void setEndDateParameter(Parameter newEndDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				_parameters.set(i, newEndDateParameter);
			}
		}
	}
	
	public void setEndTimeParameter(Parameter newEndTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				_parameters.set(i, newEndTimeParameter);
			}
		}
	}
	
	public void setCategoryParameter(Parameter newCategoryParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				_parameters.set(i, newCategoryParameter);
			}
		}
	}
	
	public void setPriorityParameter(Parameter newPriorityParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				_parameters.set(i, newPriorityParameter);
			}
		}
	}
	
	public void removeIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.remove(i);
				break;
			}
		}
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Entry) {
			Entry entry = (Entry) obj;
			Entry currentEntry = new Entry(this);
			Entry comparedEntry = new Entry(entry);
			
			currentEntry.removeIndexParameter();
			comparedEntry.removeIndexParameter();
			if (currentEntry.toString().equals(comparedEntry.toString())) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	
	@Override
	public String toString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			entryDetails = entryDetails.concat(detailType).concat(": ").concat(detail).concat("\n");
		}
		
		return entryDetails;
	}
	
	public String toHTMLString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			entryDetails = entryDetails.concat("<b>" + detailType + "</b>").concat(": ").concat(detail).concat("<br>");
		}
		
		return entryDetails;
	}
	
	public String toUIString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			if (!detailType.equals("INDEX") && !detailType.equals("CATEGORY") && !detailType.equals("PRIORITY")) {
				switch (detailType) {
					case STRING_NAME :
						entryDetails += detail + "\n";
						break;
					case STRING_DATE :
						if (getTimeParameter() != null) {
							entryDetails += "On " + detail + " ";
						} else {
							entryDetails += "On " + detail + "\n";
						}
						break;
					case STRING_TIME :
						entryDetails += detail + "\n";
						break;
					case STRING_START_DATE :
						if (getStartTimeParameter() != null) {
							entryDetails += "From " + detail + " ";
						} else {
							entryDetails += "From " + detail + " To ";
						}
						break;
					case STRING_START_TIME :
						entryDetails += detail + " To ";
						break;
					case STRING_END_DATE:
						if (getEndTimeParameter() != null) {
							entryDetails += detail + " ";
						} else {
							entryDetails += detail + "\n";
						}
						break;
					case STRING_END_TIME :
						entryDetails += detail + "\n";
						break;
					default:
						entryDetails += detail + "\n";
						break;
				}
			}
		}
		
		return entryDetails;
	}
	
}
```
###### src\com\taskboard\main\util\Parameter.java
``` java
package com.taskboard.main.util;

/**
 * This class is used as a container class comprising of ParameterType and a 
 * String denoting the value carried by the Parameter.
 * @author Alvian Prasetya
 */
public class Parameter {
	
	// attributes
	
	private ParameterType _parameterType;
	private String _parameterValue;
	
	// constructors
	
	public Parameter() {
		
	}
	
	public Parameter(ParameterType parameterType, String parameterValue) {
		_parameterType = parameterType;
		_parameterValue = parameterValue;
	}
	
	public Parameter(Parameter oldParameter) {
		_parameterType = oldParameter.getParameterType();
		_parameterValue = oldParameter.getParameterValue();
	}
	
	// accessors
	
	public ParameterType getParameterType() {
		return _parameterType;
	}
	
	public String getParameterValue() {
		return _parameterValue;
	}
	
	// mutators
	
	public void setParameterType(ParameterType newParameterType) {
		_parameterType = newParameterType;
	}
	
	public void setParameterValue(String newParameterValue) {
		_parameterValue = newParameterValue;
	}
	
}
```
###### src\com\taskboard\main\util\ParameterType.java
``` java
package com.taskboard.main.util;

public enum ParameterType {
	INDEX, NAME, NEW_NAME, DATE, TIME, START_DATE, START_TIME, END_DATE, 
	END_TIME, PRIORITY, CATEGORY;
}
```
###### src\com\taskboard\test\CommandParserTest.java
``` java
package com.taskboard.test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Date;
import java.util.Collections;

import java.text.SimpleDateFormat;

import com.taskboard.main.comparator.ParameterComparator;
import com.taskboard.main.parser.AddParameterParser;
import com.taskboard.main.parser.CommandTypeParser;
import com.taskboard.main.parser.CompleteParameterParser;
import com.taskboard.main.parser.DeleteParameterParser;
import com.taskboard.main.parser.EditParameterParser;
import com.taskboard.main.parser.ViewParameterParser;
import com.taskboard.main.util.CommandType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

/**
 * This is a unit test class for CommandParser class. It constitutes of tests 
 * for CommandTypeParser and tests for ParameterParser. All the tests are distributed 
 * using equivalence partitioning for maximum case coverage.
 * @author Alvian Prasetya
 */
public class CommandParserTest {
	
	private static final String STRING_SPACE = " ";
	private static final String STRING_NEW_LINE = "\n";
	
	@Test
	public void testCommandTypeParserAdd1() {
		// lower case partition
		assertCommandType(CommandType.ADD, "add");
	}
	
	@Test
	public void testCommandTypeParserAdd2() {
		// mixed case partition
		assertCommandType(CommandType.ADD, "aDd");
	}
	
	@Test
	public void testCommandTypeParserAdd3() {
		// upper case partition
		assertCommandType(CommandType.ADD, "ADD");
	}

	@Test
	public void testCommandTypeParserAdd4() {
		// alternative format partition
		assertCommandType(CommandType.ADD, "a");
	}
	
	@Test
	public void testCommandTypeParserEdit1() {
		// upper case partition
		assertCommandType(CommandType.EDIT, "edit");
	}
	
	@Test
	public void testCommandTypeParserEdit2() {
		// mixed case partition
		assertCommandType(CommandType.EDIT, "eDiT");
	}
	
	@Test
	public void testCommandTypeParserEdit3() {
		// lower case partition
		assertCommandType(CommandType.EDIT, "EDIT");
	}
	
	@Test
	public void testCommandTypeParserEdit4() {
		// alternative format partition
		assertCommandType(CommandType.EDIT, "e");
	}
	
	@Test
	public void testCommandTypeParserDelete1() {
		// lower case partition
		assertCommandType(CommandType.DELETE, "delete");
	}
	
	@Test
	public void testCommandTypeParserDelete2() {
		// mixed case partition
		assertCommandType(CommandType.DELETE, "deLeTE");
	}
	
	@Test
	public void testCommandTypeParserDelete3() {
		// upper case partition
		assertCommandType(CommandType.DELETE, "DELETE");
	}
	
	@Test
	public void testCommandTypeParserDelete4() {
		// alternative format partition
		assertCommandType(CommandType.DELETE, "d");
	}
	
	@Test
	public void testCommandTypeParserView1() {
		// lower case partition
		assertCommandType(CommandType.VIEW, "view");
	}
	
	@Test
	public void testCommandTypeParserView2() {
		// mixed case partition
		assertCommandType(CommandType.VIEW, "ViEW");
	}
	
	@Test
	public void testCommandTypeParserView3() {
		// upper case partition
		assertCommandType(CommandType.VIEW, "VIEW");
	}
	
	@Test
	public void testCommandTypeParserView4() {
		// alternative format partition
		assertCommandType(CommandType.VIEW, "v");
	}
	
	@Test
	public void testCommandTypeParserUnknown1() {
		// this is a mixed case unknown command partition
		assertCommandType(CommandType.UNKNOWN, "Addt");
	}
	
	@Test
	public void testCommandTypeParserUnknown2() {
		// this is a boundary case for empty string
		assertCommandType(CommandType.UNKNOWN, "");
	}
	
	@Test
	public void testCommandTypeParserUnknown3() {
		// this is a boundary case for spaces-only string
		assertCommandType(CommandType.UNKNOWN, "   ");
	}
	
	@Test
	public void testParameterParserAdd1() {
		// floating task adding testParameterParser, 'multiple tokens' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.NAME, "Hello again World!"));
		
		assertAddParameters(expected, "add Hello again World!");
	}
	
	@Test
	public void testParameterParserAdd2() {
		// adding of complex descriptive task, 'multiple constraints' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.NAME, "Meet Chris"));
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat("dd/MM/yyyy");
		Date today = new Date();
		Date tomorrow = new Date(today.getTime() + (1000 * 60 * 60 * 24));
		expected.add(new Parameter(ParameterType.START_DATE, defaultDateFormat.format(tomorrow)));
		expected.add(new Parameter(ParameterType.START_TIME, "19:00"));
		expected.add(new Parameter(ParameterType.END_DATE, defaultDateFormat.format(tomorrow)));
		expected.add(new Parameter(ParameterType.END_TIME, "21:00"));
		expected.add(new Parameter(ParameterType.CATEGORY, "meeting"));
		expected.add(new Parameter(ParameterType.PRIORITY, "high"));
		
		assertAddParameters(expected, "add Meet Chris from tomorrow 7pm to tomorrow 9pm cat meeting pri high");
	}
	
	@Test
	public void testParameterParserAdd3() {
		// adding of task with name containing a delimiter, 'ambiguous delimiter' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.NAME, "Go to School from Home"));
		expected.add(new Parameter(ParameterType.CATEGORY, "daily"));
		expected.add(new Parameter(ParameterType.PRIORITY, "high"));
		
		assertAddParameters(expected, "add Go to School from Home pri hi cat daily");
	}
	
	@Test
	public void testParameterParserEdit1() {
		// editing of complex descriptive task, 'multiple constraints' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.INDEX, "12"));
		expected.add(new Parameter(ParameterType.NEW_NAME, "testParameterParser at school"));
		expected.add(new Parameter(ParameterType.DATE, "13/10/2020"));
		expected.add(new Parameter(ParameterType.TIME, "14:00"));
		expected.add(new Parameter(ParameterType.PRIORITY, "medium"));
		expected.add(new Parameter(ParameterType.CATEGORY, "testParameterParser"));
		
		assertEditParameters(expected, "edit 12 testParameterParser at school at 13/10/2020 14:00 pri med cat testParameterParser");
	}
	
	@Test
	public void testParameterParserDelete1() {
		// deleting task by index
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.INDEX, "102"));
		
		assertDeleteParameters(expected, "delete 102");
	}
	
	@Test
	public void testParameterParserDelete2() {
		// deleting of complex descriptive tasks, 'multiple constraints' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.CATEGORY, "other"));
		expected.add(new Parameter(ParameterType.PRIORITY, "low"));
		expected.add(new Parameter(ParameterType.START_DATE, "23/10/2015"));
		expected.add(new Parameter(ParameterType.END_DATE, "28/10/2015"));
		
		assertDeleteParameters(expected, "delete cat other pri low from 23/10/2015 to 28/10/2015");
	}
	
	@Test
	public void testParameterParserView1() {
		// viewing of all tasks, 'no constraint' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		
		assertViewParameters(expected, "view");
	}
	
	@Test
	public void testParameterParserView2() {
		// selective viewing of complex descriptive tasks, 'multiple constraints' partition
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.DATE, "25/10/2015"));
		expected.add(new Parameter(ParameterType.CATEGORY, "Homework"));
		expected.add(new Parameter(ParameterType.PRIORITY, "low"));
		
		assertViewParameters(expected, "view by 25/10/2015 cat Homework pri low");
	}
	
	@Test
	public void testParameterParserComplete1() {
		// checking/marking of a task
		ArrayList<Parameter> expected = new ArrayList<Parameter>();
		expected.add(new Parameter(ParameterType.INDEX, "5"));
		
		assertCheckParameters(expected, "complete 5");
	}
	
	private void assertCommandType(CommandType expected, String command) {
		assertEquals(expected, new CommandTypeParser().parseCommandType(command)); 
	}
	
	private void assertAddParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new AddParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertEditParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new EditParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertDeleteParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new DeleteParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertViewParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new ViewParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertCheckParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new CompleteParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private static String toString(ArrayList<Parameter> parameters) {
		String resultString = new String();
		
		for (int i = 0; i < parameters.size(); i++) {
			resultString += parameters.get(i).getParameterType().name();
			resultString += STRING_SPACE;
			resultString += parameters.get(i).getParameterValue();
			resultString += STRING_NEW_LINE;
		}
		
		return resultString;
	}

}
```
