# A0126536E
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\BackgroundCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.awt.Image;

import javax.imageio.ImageIO;

import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class BackgroundCommand extends Command {

	private static final String MESSAGE_SET_BACKGROUND_SUCCESS = "Succesfully changed background image.";
	private static final String MESSAGE_SET_BACKGROUND_FAILURE = "The image format is not supported.";
	private static final String MESSAGE_FILE_NOT_FOUND = "The specified image does not exist.";
	
	public BackgroundCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForBackground = new Response();
		
		assert (_parameters.size() == 1) : "Critical error: Background command parameter not found.";
		String imageFilePathString = _parameters.get(0).getParameterValue();
		File imageFilePath = new File(imageFilePathString);
		if (imageFilePath.exists() && !imageFilePath.isDirectory()) {
			try {
				UserInterface.getInstance().setBackgroundPath(imageFilePathString);
				_tempStorageManipulator.setBackgroundPath(imageFilePathString);
				responseForBackground.setIsSuccess(true);
				responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_SUCCESS);
			} catch (IOException e) {
				responseForBackground.setIsSuccess(false);
				responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_FAILURE);
			}
		} else {
			try {
				URL imageURLPathString = new URL(imageFilePathString);
				final HttpURLConnection connection = (HttpURLConnection) imageURLPathString.openConnection();
				connection.setRequestProperty(
				    "User-Agent",
				    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31");
				Image imageFileURL = ImageIO.read(connection.getInputStream());
				if (imageFileURL != null) {
					UserInterface.getInstance().setBackgroundPath(imageFilePathString);
					_tempStorageManipulator.setBackgroundPath(imageFilePathString);
					responseForBackground.setIsSuccess(true);
					responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_SUCCESS);
				} else {
					responseForBackground.setIsSuccess(false);
					responseForBackground.setFeedback(MESSAGE_FILE_NOT_FOUND);
				}
			} catch (MalformedURLException e) {
				responseForBackground.setIsSuccess(false);
				responseForBackground.setFeedback(MESSAGE_FILE_NOT_FOUND);
			} catch (IOException e) {
					responseForBackground.setIsSuccess(false);
					responseForBackground.setFeedback(MESSAGE_SET_BACKGROUND_FAILURE);
			}
		}
		
		return responseForBackground;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\HelpCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;

import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class HelpCommand extends Command {

	public HelpCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForHelp = new Response();
		ArrayList<Entry> helpList = new ArrayList<Entry>();
		
		for (int i = 0; i < 32; i++) {
			helpList.add(new Entry());
		}
		helpList.get(0).addToParameters(new Parameter(null, "<center><b>Command</b></center>"));
		helpList.get(1).addToParameters(new Parameter(null, "<center><b>Description</b></center>"));
		
		helpList.get(2).addToParameters(new Parameter(null, "<b>add</b> NAME <b>by</b> DATE TIME"));
		helpList.get(3).addToParameters(new Parameter(null, "Add a deadline task"));
		
		helpList.get(4).addToParameters(new Parameter(null, "<b>add</b> NAME <b>from</b> DATE TIME <b>to</b> DATE TIME"));
		helpList.get(5).addToParameters(new Parameter(null, "Add an event"));
		
		helpList.get(6).addToParameters(new Parameter(null, "<b>add</b> NAME"));
		helpList.get(7).addToParameters(new Parameter(null, "Add a side task"));
		
		helpList.get(8).addToParameters(new Parameter(null, "<b>edit</b> INDEX SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(9).addToParameters(new Parameter(null, "Edit entry with specified index"));
		
		helpList.get(10).addToParameters(new Parameter(null, "<b>delete</b> INDEX"));
		helpList.get(11).addToParameters(new Parameter(null, "Delete entry with specified index"));
		
		helpList.get(12).addToParameters(new Parameter(null, "<b>delete</b> SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(13).addToParameters(new Parameter(null, "Delete entries that meet the specifications"));
		
		helpList.get(14).addToParameters(new Parameter(null, "<b>view</b> SPECIFICATIONS <font color='red'>*</font>"));
		helpList.get(15).addToParameters(new Parameter(null, "View entries that meet the specifications"));
		
		helpList.get(16).addToParameters(new Parameter(null, "<b>complete</b> INDEX"));
		helpList.get(17).addToParameters(new Parameter(null, "Mark entry with specified index as completed"));
		
		helpList.get(18).addToParameters(new Parameter(null, "<b>restore</b> INDEX"));
		helpList.get(19).addToParameters(new Parameter(null, "Restore entry with specified index from archive"));
		
		helpList.get(20).addToParameters(new Parameter(null, "<b>archive</b>"));
		helpList.get(21).addToParameters(new Parameter(null, "Display archived entries"));
		
		helpList.get(22).addToParameters(new Parameter(null, "<b>reminder</b> NUM_OF_HOUR(S)"));
		helpList.get(23).addToParameters(new Parameter(null, "Set reminder to the specified number of hours"));
		
		helpList.get(24).addToParameters(new Parameter(null, "<b>background</b> IMAGE_FILE_PATH"));
		helpList.get(25).addToParameters(new Parameter(null, "Set the specified image file as background"));
		
		helpList.get(26).addToParameters(new Parameter(null, "<b>background</b> IMAGE_URL"));
		helpList.get(27).addToParameters(new Parameter(null, "Set the specified image URL as background"));
		
		helpList.get(28).addToParameters(new Parameter(null, "<b>command</b>"));
		helpList.get(29).addToParameters(new Parameter(null, "View TaskBoard's command list"));
		
		helpList.get(30).addToParameters(new Parameter(null, "<b>exit</b>"));
		helpList.get(31).addToParameters(new Parameter(null, "Quit the program"));
		
		responseForHelp.setIsSuccess(true);
		responseForHelp.setFeedback("Successfully displayed all entries in command list.");
		responseForHelp.setEntries(helpList);
		
		return responseForHelp;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\ReminderCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.IOException;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.userinterface.UserInterface;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class ReminderCommand extends Command {
	
	private static final String MESSAGE_SET_REMINDER_SUCCESS = "Reminder succesfully set to %1$s hour(s).";
	private static final String MESSAGE_SET_REMINDER_FAILURE = "Reminder could not be set to %1$s hour(s).";
	
	public ReminderCommand(ArrayList<Parameter> parameters) {
		assert parameters != null;
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
		
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Response executeCommand() {
		Response responseForReminder = new Response();
		
		assert (_parameters.size() == 1) : "Critical error: Reminder command parameter not found.";
		String reminderHourString = _parameters.get(0).getParameterValue();
		int reminderHour = Integer.parseInt(reminderHourString);
		
		if (reminderHour < 0) {
			responseForReminder.setIsSuccess(false);
			responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_FAILURE, reminderHourString));
		} else {
			UserInterface.getInstance().setReminderHour(reminderHour);
			try {
				_tempStorageManipulator.setReminderHour(reminderHour);
				responseForReminder.setIsSuccess(true);
				responseForReminder.setEntries(_tempStorageManipulator.getTempStorage());
				responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_SUCCESS, reminderHourString));
			} catch (IOException e) {
				responseForReminder.setIsSuccess(false);
				responseForReminder.setFeedback(String.format(MESSAGE_SET_REMINDER_FAILURE, reminderHourString));
			}
		}
		
		return responseForReminder;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\command\UndoCommand.java
``` java
package com.taskboard.main.command;

import java.util.ArrayList;
import java.io.IOException;

import com.taskboard.main.TempStorageManipulator;
import com.taskboard.main.util.Entry;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.Response;

public class UndoCommand extends Command {
	
	private static final String MESSAGE_UNDO_SUCCESS = "Succesfully undo last operation.";
	private static final String MESSAGE_UNDO_FAILURE = "Undo failed: no previous checkpoint found.";
	
	public UndoCommand(ArrayList<Parameter> parameters) {
		_parameters = parameters;
		
		if (getTempStorageManipulator() == null) {
			_tempStorageManipulator = new TempStorageManipulator();
		}
	}
	
	public Response executeCommand() {
		Response responseForUndo = new Response();
		
		ArrayList<Entry> initialTempStorage = new ArrayList<Entry>();
		ArrayList<Entry> initialTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getTempStorage()) {
			initialTempStorage.add(new Entry(entry));
		}
		for (Entry entry: _tempStorageManipulator.getTempArchive()) {
			initialTempArchive.add(new Entry(entry));
		}
		
		ArrayList<Entry> lastTempStorage = new ArrayList<Entry>();
		ArrayList<Entry> lastTempArchive = new ArrayList<Entry>();
		for (Entry entry: _tempStorageManipulator.getLastTempStorage()) {
			lastTempStorage.add(new Entry(entry));
		}
		for (Entry entry: _tempStorageManipulator.getLastTempArchive()) {
			lastTempArchive.add(new Entry(entry));
		}
		
		if (!lastTempStorage.isEmpty() && !lastTempArchive.isEmpty()) {
			responseForUndo.setIsSuccess(true);
			responseForUndo.setFeedback(MESSAGE_UNDO_SUCCESS);
			responseForUndo.setEntries(lastTempStorage);
			// Only updates the lastTempStorage & lastTempArchive upon successful execution.
			try {
				_tempStorageManipulator.setTempStorage(lastTempStorage);
				_tempStorageManipulator.setLastTempStorage(initialTempStorage);
				_tempStorageManipulator.setTempArchive(lastTempArchive);
				_tempStorageManipulator.setLastTempArchive(initialTempArchive);
			} catch (IOException e) {
				// Handle exceptions here
			}
		} else {
			responseForUndo.setIsSuccess(false);
			responseForUndo.setFeedback(MESSAGE_UNDO_FAILURE);
		}
		
		return responseForUndo;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\formatvalidator\DateFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

import java.text.SimpleDateFormat;
import java.text.ParseException;

import java.util.Calendar;
import java.util.Date;

public class DateFormatValidator implements FormatValidator {
	
	// constants
	
	public static final int MILLISECONDS_PER_DAY = 86400000;
	public static final int DAY_INDEX_MONDAY = 1;
	public static final int DAY_INDEX_TUESDAY = 2;
	public static final int DAY_INDEX_WEDNESDAY = 3;
	public static final int DAY_INDEX_THURSDAY = 4;
	public static final int DAY_INDEX_FRIDAY = 5;
	public static final int DAY_INDEX_SATURDAY = 6;
	public static final int DAY_INDEX_SUNDAY = 7;
	public static final String DEFAULT_DATE_FORMAT = "dd/MM/yyyy";
	
	// constructors
	
	public DateFormatValidator() {
		
	}
	
	// functionalities
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "tda":
			case "today":
			case "tomo":
			case "tomorrow":
			case "mon":
			case "monday":
			case "tue":
			case "tuesday":
			case "wed":
			case "wednesday":
			case "thu":
			case "thursday":
			case "fri":
			case "friday":
			case "sat":
			case "saturday":
			case "sun":
			case "sunday":
				return true;
			default:
				if (isMatchingDateFormat(new SimpleDateFormat("d/MM/yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd/MM/yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d-MM-yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd-MM-yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d/MM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd/MM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d-MM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd-MM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMMMM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMMMM"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMM yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMM yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMMMM yyyy"), token)) {
					return true;
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMMMM yyyy"), token)) {
					return true;
				} else {
					return false;
				}
		}
	}
	
	public String toDefaultFormat(String token) {
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
		Date today = new Date();
		
		token = token.toLowerCase();
		switch (token) {
			case "tda":
			case "today":
				return defaultDateFormat.format(today);
			case "tomo":
			case "tomorrow":
				Date tomorrow = new Date(today.getTime() + MILLISECONDS_PER_DAY);
				return defaultDateFormat.format(tomorrow);
			case "mon":
			case "monday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_MONDAY));
			case "tue":
			case "tuesday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_TUESDAY));
			case "wed":
			case "wednesday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_WEDNESDAY));
			case "thu":
			case "thursday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_THURSDAY));
			case "fri":
			case "friday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_FRIDAY));
			case "sat":
			case "saturday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_SATURDAY));
			case "sun":
			case "sunday":
				return defaultDateFormat.format(getNextOccurenceDate(DAY_INDEX_SUNDAY));
			default:
				if (isMatchingDateFormat(new SimpleDateFormat("d/MM/yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d/MM/yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd/MM/yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd/MM/yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d-MM-yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d-MM-yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd-MM-yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd-MM-yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d/MM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d/MM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd/MM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd/MM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d-MM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d-MM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd-MM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd-MM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d MMM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd MMM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMMMM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d MMMMM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMMMM"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd MMMMM"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMM yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d MMM yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMM yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd MMM yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("d MMMMM yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("d MMMMM yyyy"), token);
				} else if (isMatchingDateFormat(new SimpleDateFormat("dd MMMMM yyyy"), token)) {
					return toStandardDateFormat(new SimpleDateFormat("dd MMMMM yyyy"), token);
				} else {
					return null;
				}
		}
	}
	
	private static Date getNextOccurenceDate(int dayIndex) {
		SimpleDateFormat dayIndexFormat = new SimpleDateFormat("u");
		Date today = new Date();
		int todayDayIndex = Integer.parseInt(dayIndexFormat.format(today));
		
		if (todayDayIndex < dayIndex) {
			Date target = new Date(today.getTime() + MILLISECONDS_PER_DAY * 
						  (dayIndex - todayDayIndex));
			assert (!today.after(target)); // today must be either before or the same day as target
			return target;
		} else {
			Date target = new Date(today.getTime() + MILLISECONDS_PER_DAY * 
					  	  (dayIndex - todayDayIndex + 7));
			assert (!today.after(target)); // today must be either before or the same day as target
			return target;
		}
	}
	
	private static boolean isMatchingDateFormat(SimpleDateFormat dateFormat, String input) {
		try {
			String output = dateFormat.format(dateFormat.parse(input));
			if (output.equalsIgnoreCase(input)) {
				return true;
			} else {
				return false;
			}
		} catch (ParseException e) {
			return false;
		}
	}
	
	private static String toStandardDateFormat(SimpleDateFormat dateFormat, String input) {
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
		try {
			if (!dateFormat.toPattern().contains("y")) {
				Calendar currentDate = Calendar.getInstance();
				Calendar parsedDate = Calendar.getInstance();
				
				parsedDate.setTime(dateFormat.parse(input));
				parsedDate.set(Calendar.YEAR, currentDate.get(Calendar.YEAR));
				
				if (parsedDate.before(currentDate)) {
					parsedDate.set(Calendar.YEAR, currentDate.get(Calendar.YEAR) + 1);
				}
				
				String output = defaultDateFormat.format(parsedDate.getTime());
				return output;
			} else {
				String output = defaultDateFormat.format(dateFormat.parse(input));
				return output;
			}
		} catch (ParseException e) {
			assert false: "Code should not be reached.";
			return null;
		}
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\formatvalidator\FormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

public interface FormatValidator {

	public boolean isValidFormat(String token);
	public String toDefaultFormat(String token);
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\formatvalidator\NumberFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

public class NumberFormatValidator implements FormatValidator {
	
	public NumberFormatValidator() {
		
	}
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		if (isNumeric(token)) {
			return true;
		} else {
			return false;
		}
	}
	
	public static boolean isNumeric(String token) {
		try {
			Integer.parseInt(token);
		} catch (NumberFormatException nfe) {
			return false;
		}
		return true;
	}
	
	public String toDefaultFormat(String token) {
		return token;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\formatvalidator\PriorityFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

public class PriorityFormatValidator implements FormatValidator {

	// constructors
	
	public PriorityFormatValidator() {
		
	}
	
	// functionalies
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "l":
			case "lo":
			case "low":
			case "m":
			case "med":
			case "medium":
			case "h":
			case "hi":
			case "high":
				return true;
			default:
				return false;
		}
	}
	
	public String toDefaultFormat(String token) {
		token = token.toLowerCase();
		switch (token) {
			case "l":
			case "lo":
			case "low":
				return new String("low");
			case "m":
			case "med":
			case "medium":
				return new String("medium");
			case "h":
			case "hi":
			case "high":
				return new String("high");
			default:
				return null;
		}
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\formatvalidator\TimeFormatValidator.java
``` java
package com.taskboard.main.formatvalidator;

public class TimeFormatValidator implements FormatValidator {

	public TimeFormatValidator() {
		
	}
	
	public boolean isValidFormat(String token) {
		token = token.toLowerCase();
		if (token.indexOf("am") == 1 && token.length() == 3) {
			return true;
		} else if (token.indexOf("am") == 2 && token.length() == 4) {
			return true;
		} else if (token.indexOf("pm") == 1 && token.length() == 3) {
			return true;
		} else if (token.indexOf("pm") == 2 && token.length() == 4) {
			return true;
		} else if (token.indexOf(":") == 1 && token.length() == 4) {
			return true;
		} else if (token.indexOf(":") == 2 && token.length() == 5) {
			return true;
		} else if (token.indexOf(".") == 1 && token.length() == 4) {
			return true;
		} else if (token.indexOf(".") == 2 && token.length() == 5) {
			return true;
		} else {
			return false;
		}
	}
	
	public String toDefaultFormat(String token) {
		String hh = "";
		String mm = "";
		
		token = token.toLowerCase();
		if (token.indexOf("am") == 1 && token.length() == 3) {
			hh = "0" + token.substring(0, token.indexOf("am"));
			// 12am is 00:00
			if (hh.equals("12")) {
				hh = "00";
			}
			mm = "00";
		} else if (token.indexOf("am") == 2 && token.length() == 4) {
			hh = token.substring(0, token.indexOf("am"));
			// 12am is 00:00
			if (hh.equals("12")) {
				hh = "00";
			}
			mm = "00";
		} else if (token.indexOf("pm") == 1 && token.length() == 3) {
			hh = Integer.toString(Integer.parseInt(token.substring(0, token.indexOf("pm"))) + 12);
			// 12pm is 12:00
			if (hh.equals("24")) {
				hh = "12";
			}
			mm = "00";
		} else if (token.indexOf("pm") == 2 && token.length() == 4) {
			hh = Integer.toString(Integer.parseInt(token.substring(0, token.indexOf("pm"))) + 12);
			// 12pm is 12:00
			if (hh.equals("24")) {
				hh = "12";
			}
			mm = "00";
		} else if (token.indexOf(":") == 1 && token.length() == 4) {
			hh = "0" + token.substring(0, token.indexOf(":"));
			mm = token.substring(token.indexOf(":") + 1);
		} else if (token.indexOf(":") == 2 && token.length() == 5) {
			hh = token.substring(0, token.indexOf(":"));
			mm = token.substring(token.indexOf(":") + 1);
		} else if (token.indexOf(".") == 1 && token.length() == 4) {
			hh = "0" + token.substring(0, token.indexOf("."));
			mm = token.substring(token.indexOf(".") + 1);
		} else if (token.indexOf(".") == 2 && token.length() == 5) {
			hh = token.substring(0, token.indexOf("."));
			mm = token.substring(token.indexOf(".") + 1);
		} else {
			assert false: "Found a foreign case for time validator.";
		}
		
		return hh + ":" + mm;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\GlobalLogger.java
``` java
package com.taskboard.main;

import java.io.IOException;

import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.Date;

import java.text.SimpleDateFormat;

public class GlobalLogger {
	
	private static final String logDirectory = "logs/";
	private static final String logFileName = new SimpleDateFormat("dd-MM-yyyy_hh.mm.ss").format(new Date());
	private static final String logFileFormat = ".log";
	
	private static GlobalLogger _instance = null;
	private static Logger _logger;
	private static FileHandler _loggerFileHandler;
	private static SimpleFormatter _loggerFormatter;
	
	private GlobalLogger() {
		try {
			_loggerFileHandler = new FileHandler(logDirectory + logFileName + logFileFormat, true);
		} catch (IOException exception) {
			// TBA: process exception or throw exception
		}
		_loggerFormatter = new SimpleFormatter();
		_loggerFileHandler.setFormatter(_loggerFormatter);
		_logger = Logger.getLogger(logFileName);
		_logger.addHandler(_loggerFileHandler);
	}
	
	public static GlobalLogger getInstance() {
		if (_instance == null) {
			_instance = new GlobalLogger();
		}
		return _instance;
	}
	
	public Logger getLogger() {
		return _logger;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\AddParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.DateFormatValidator;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.PriorityFormatValidator;
import com.taskboard.main.formatvalidator.TimeFormatValidator;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class AddParameterParser implements ParameterParser {
	
	private Logger _logger;
	
	public AddParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of ADD command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.add(new Parameter(ParameterType.NAME, parameterString));
		} else {
			int expectedDelimiterId = 0;
			DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
			String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
			
			String temporaryString = new String();
			String[] tokens = parameterString.split(" ");
			for (int i = tokens.length - 1; i >= 0; i--) {
				if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
					if (temporaryString.isEmpty()) {
						throw new IllegalArgumentException("Empty " + expectedDelimiterName + " parameter provided.");
					} else {
						temporaryString = reverseTokens(temporaryString);
						ArrayList<Parameter> parametersToAdd = convertToParameters(temporaryString, expectedDelimiterType);
						temporaryString = reverseTokens(temporaryString);
						if (parametersToAdd.isEmpty()) {
							temporaryString += ' ' + tokens[i];
						} else {
							parameters.addAll(parametersToAdd);
							temporaryString = "";
						}
					}
					
					expectedDelimiterId++;
					if (expectedDelimiterId < delimiterTypes.size()) {
						expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
						expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
					} else {
						expectedDelimiterType = null;
						expectedDelimiterName = new String(); // name does not have delimiter
					}
				} else {
					temporaryString += ' ' + tokens[i];
				}
			}
			if (!temporaryString.isEmpty()) {
				temporaryString = reverseTokens(temporaryString);
				parameters.add(new Parameter(ParameterType.NAME, temporaryString));
			}
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of ADD command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		if (!isParameterExists(parameters, ParameterType.NAME)) {
			throw new IllegalArgumentException("No entry name provided.");
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = new String();
		
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + ' ';
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		FormatValidator priorityFormatValidator = new PriorityFormatValidator();
		
		switch (delimiterType) {
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case EVERY:
				// TBD: recurring task
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString, priorityFormatValidator));
				break;
			default:
				break;
		}
		
		return parameters;
	}
	
	private boolean isParameterExists(ArrayList<Parameter> parameters, ParameterType parameterType) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == parameterType) {
				return true;
			}
		}
		return false;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\BackgroundParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class BackgroundParameterParser implements ParameterParser {

	private Logger _logger;
	
	public BackgroundParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of BACKGROUND command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		parameters.add(new Parameter(ParameterType.NAME, parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of BACKGROUND command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\CommandParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.command.AddCommand;
import com.taskboard.main.command.ArchiveCommand;
import com.taskboard.main.command.BackgroundCommand;
import com.taskboard.main.command.Command;
import com.taskboard.main.command.CompleteCommand;
import com.taskboard.main.command.DeleteCommand;
import com.taskboard.main.command.EditCommand;
import com.taskboard.main.command.HelpCommand;
import com.taskboard.main.command.InvalidCommand;
import com.taskboard.main.command.NewCommand;
import com.taskboard.main.command.OpenCommand;
import com.taskboard.main.command.ReminderCommand;
import com.taskboard.main.command.RestoreCommand;
import com.taskboard.main.command.UndoCommand;
import com.taskboard.main.command.ViewCommand;
import com.taskboard.main.util.CommandType;
import com.taskboard.main.util.Parameter;

public class CommandParser {
	
	private CommandTypeParser _commandTypeParser;
	private ParameterParser _parameterParser;
	private Logger _logger;
	
	public CommandParser() {
		_commandTypeParser = new CommandTypeParser();
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public Command parseCommand(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing command string: " + commandString);
		CommandType newCommandType = _commandTypeParser.parseCommandType(commandString);
		switch (newCommandType) {
			case NEW:
				_parameterParser = new OpenParameterParser();
				ArrayList<Parameter> newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing NEW command string");
				return new NewCommand(newCommandParameters);
			case OPEN:
				_parameterParser = new OpenParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing OPEN command string");
				return new OpenCommand(newCommandParameters);
			case ADD:
				_parameterParser = new AddParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing ADD command string");
				return new AddCommand(newCommandParameters);
			case EDIT:
				_parameterParser = new EditParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing EDIT command string");
				return new EditCommand(newCommandParameters);
			case DELETE:
				_parameterParser = new DeleteParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing DELETE command string");
				return new DeleteCommand(newCommandParameters);
			case VIEW:
				_parameterParser = new ViewParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing VIEW command string");
				return new ViewCommand(newCommandParameters);
			case COMPLETE:
				_parameterParser = new CompleteParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing COMPLETE command string");
				return new CompleteCommand(newCommandParameters);
			case RESTORE:
				_parameterParser = new RestoreParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing RESTORE command string");
				return new RestoreCommand(newCommandParameters);
			case ARCHIVE:
				_logger.log(Level.INFO, "Finished parsing ARCHIVE command string");
				return new ArchiveCommand(null);
			case UNDO:
				_logger.log(Level.INFO, "Finished parsing UNDO command string");
				return new UndoCommand(null);
			case BACKGROUND:
				_parameterParser = new BackgroundParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing BACKGROUND command string");
				return new BackgroundCommand(newCommandParameters);
			case REMINDER:
				_parameterParser = new ReminderParameterParser();
				newCommandParameters = _parameterParser.parseParameters(commandString);
				_logger.log(Level.INFO, "Finished parsing REMINDER command string");
				return new ReminderCommand(newCommandParameters);
			case HELP:
				_logger.log(Level.INFO, "Finished parsing HELP command string");
				return new HelpCommand(null);
			case UNKNOWN:
				_logger.log(Level.INFO, "Finished parsing UNKNOWN command string");
				return new InvalidCommand(null);
			default:
				_logger.log(Level.SEVERE, "Unexpected execution of unreachable code in CommandParser");
				assert false : "Unexpected execution of unreachable code";
				return null;
		}
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\CommandTypeParser.java
``` java
package com.taskboard.main.parser;

import com.taskboard.main.util.CommandType;

public class CommandTypeParser {

	public CommandTypeParser() {
		
	}
	
	public CommandType parseCommandType(String commandString) {
		String commandTypeString = extractCommandTypeString(commandString).toLowerCase();
		
		switch (commandTypeString) {
			case "a":
			case "add":
				return CommandType.ADD;
			case "e":
			case "edit":
				return CommandType.EDIT;
			case "d":
			case "delete":
				return CommandType.DELETE;
			case "v":
			case "view":
				return CommandType.VIEW;
			case "o":
			case "open":
				return CommandType.OPEN;
			case "n":
			case "new":
				return CommandType.NEW;
			case "done":
			case "c":
			case "check":
			case "complete":
				return CommandType.COMPLETE;
			case "r":
			case "restore":
			case "revert":
				return CommandType.RESTORE;
			case "arc":
			case "arch":
			case "archive":
				return CommandType.ARCHIVE;
			case "undo":
			case "un":
			case "u":
				return CommandType.UNDO;
			case "background":
			case "bg":
				return CommandType.BACKGROUND;
			case "reminder":
			case "remind":
				return CommandType.REMINDER;
			case "h":
			case "help":
			case "cmd":
			case "command":
			case "commands":
				return CommandType.HELP;
			case "esc":
			case "exit":
				return CommandType.EXIT;
			default:
				return CommandType.UNKNOWN;
		}
	}
	
	public static String extractCommandTypeString(String commandString) {
		if (commandString.indexOf(' ') == -1) {
			return commandString;
		} else {
			return commandString.substring(0, commandString.indexOf(' ')).toLowerCase();
		}
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\CompleteParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.util.Parameter;

public class CompleteParameterParser implements ParameterParser {

	private Logger _logger;
	
	public CompleteParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of COMPLETE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		FormatValidator indexFormatValidator =  new NumberFormatValidator();
		parameters.add(ParameterParser.getIndex(parameterString, indexFormatValidator));
		
		_logger.log(Level.INFO, "Finished parsing parameters of COMPLETE command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\DeleteParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.DateFormatValidator;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.formatvalidator.PriorityFormatValidator;
import com.taskboard.main.formatvalidator.TimeFormatValidator;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;

public class DeleteParameterParser implements ParameterParser {
	
	private Logger _logger;
	
	public DeleteParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of DELETE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.addAll(convertToParameters(parameterString, DelimiterType.NONE));
		} else {
			int expectedDelimiterId = 0;
			DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
			String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
			
			String temporaryString = new String();
			String[] tokens = parameterString.split(" ");
			for (int i = tokens.length - 1; i >= 0; i--) {
				if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
					if (temporaryString.isEmpty()) {
						throw new IllegalArgumentException("Empty " + expectedDelimiterName + " parameter provided.");
					} else {
						temporaryString = reverseTokens(temporaryString);
						ArrayList<Parameter> parametersToAdd = convertToParameters(temporaryString, expectedDelimiterType);
						temporaryString = reverseTokens(temporaryString);
						if (parametersToAdd.isEmpty()) {
							temporaryString += ' ' + tokens[i];
						} else {
							parameters.addAll(parametersToAdd);
							temporaryString = "";
						}
					}
					
					expectedDelimiterId++;
					if (expectedDelimiterId < delimiterTypes.size()) {
						expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
						expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
					} else {
						expectedDelimiterType = null;
						expectedDelimiterName = new String(); // name does not have delimiter
					}
				} else {
					temporaryString += ' ' + tokens[i];
				}
			}
			if (!temporaryString.isEmpty()) {
				temporaryString = reverseTokens(temporaryString);
				parameters.addAll(convertToParameters(temporaryString, DelimiterType.NONE));
			}
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of DELETE command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = new String();
		
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + ' ';
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		FormatValidator indexFormatValidator = new NumberFormatValidator();
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		FormatValidator priorityFormatValidator = new PriorityFormatValidator();
		
		switch (delimiterType) {
			case NONE:
				parameters.add(ParameterParser.getIndex(parameterString, indexFormatValidator));
				break;
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case EVERY:
				// TBD: recurring task
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString, priorityFormatValidator));
				break;
			default:
				break;
		}
		
		return parameters;
	}

}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\EditParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.DateFormatValidator;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.formatvalidator.PriorityFormatValidator;
import com.taskboard.main.formatvalidator.TimeFormatValidator;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class EditParameterParser implements ParameterParser {
	
	private Logger _logger;
	
	public EditParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}

	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of EDIT command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = "";
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		if (parameterString.trim().indexOf(" ") != -1) {
			FormatValidator indexFormatValidator =  new NumberFormatValidator();
			
			String indexString = parameterString.substring(0, parameterString.indexOf(" ")).trim();
			if (indexFormatValidator.isValidFormat(indexString)) {
				indexString = indexFormatValidator.toDefaultFormat(indexString);
				parameters.add(new Parameter(ParameterType.INDEX, indexString));
			} else {
				throw new IllegalArgumentException("No index provided.");
			}
			
			parameterString = parameterString.substring(parameterString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No edited details provided.");
		}
		
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.addAll(convertToParameters(parameterString, DelimiterType.NONE));
		} else {
			int expectedDelimiterId = 0;
			DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
			String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();

			String temporaryString = new String();
			String[] tokens = parameterString.split(" ");
			for (int i = tokens.length - 1; i >= 0; i--) {
				if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
					if (temporaryString.isEmpty()) {
						throw new IllegalArgumentException("Empty " + expectedDelimiterName + " parameter provided.");
					} else {
						temporaryString = reverseTokens(temporaryString);
						ArrayList<Parameter> parametersToAdd = convertToParameters(temporaryString, expectedDelimiterType);
						temporaryString = reverseTokens(temporaryString);
						if (parametersToAdd.isEmpty()) {
							temporaryString += ' ' + tokens[i];
						} else {
							parameters.addAll(parametersToAdd);
							temporaryString = "";
						}
					}

					expectedDelimiterId++;
					if (expectedDelimiterId < delimiterTypes.size()) {
						expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
						expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
					} else {
						expectedDelimiterType = null;
						expectedDelimiterName = new String(); // name does not have delimiter
					}
				} else {
					temporaryString += ' ' + tokens[i];
				}
			}
			if (!temporaryString.isEmpty()) {
				temporaryString = reverseTokens(temporaryString);
				parameters.addAll(convertToParameters(temporaryString, DelimiterType.NONE));
			}
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of EDIT command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		if (!isParameterExists(parameters, ParameterType.INDEX)) {
			throw new IllegalArgumentException("No entry index provided.");
		}
		
		return parameters;
	}

	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();

		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}

		return delimiterTypes;
	}

	private static String reverseTokens(String parameterString) {
		String resultString = new String();

		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + ' ';
		}

		return resultString.trim();
	}

	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		FormatValidator priorityFormatValidator = new PriorityFormatValidator();
		
		switch (delimiterType) {
			case NONE:
				parameters.add(ParameterParser.getNewName(parameterString));
				break;
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case EVERY:
				// TBD: recurring task
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString, priorityFormatValidator));
				break;
			default:
				break;
		}

		return parameters;
	}
	
	private boolean isParameterExists(ArrayList<Parameter> parameters, ParameterType parameterType) {
		for (int i = 0; i < parameters.size(); i++) {
			if (parameters.get(i).getParameterType() == parameterType) {
				return true;
			}
		}
		return false;
	}

}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\OpenParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class OpenParameterParser implements ParameterParser {
	
	private Logger _logger;
	
	public OpenParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of OPEN command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		parameters.add(new Parameter(ParameterType.NAME, parameterString));
		
		_logger.log(Level.INFO, "Finished parsing parameters of OPEN command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\ParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;

import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public interface ParameterParser {
	
	public ArrayList<Parameter> parseParameters(String commandString);
	
	static Parameter getIndex(String parameterString, FormatValidator indexFormatValidator) throws IllegalArgumentException {
		String trimmedParameterString = parameterString.trim();
		if (trimmedParameterString.split(" ").length == 1) {
			if (indexFormatValidator.isValidFormat(parameterString)) {
				String index = indexFormatValidator.toDefaultFormat(parameterString);
				return new Parameter(ParameterType.INDEX, index);
			} else {
				throw new IllegalArgumentException("Invalid numeric format provided.");
			}
		} else {
			throw new IllegalArgumentException("Invalid numeric format provided.");
		}
	}
	
	static Parameter getNewName(String parameterString) {
		return new Parameter(ParameterType.NEW_NAME, parameterString);
	}
	
	static ArrayList<Parameter> getStartDateTime(String parameterString, FormatValidator dateFormatValidator, 
														 FormatValidator timeFormatValidator) {
		ArrayList<Parameter> startDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(" ");
		String compoundToken = "";
		
		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + " " + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String startDate = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				startDateTime.add(new Parameter(ParameterType.START_DATE, startDate));
				compoundToken = "";
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String startDate = dateFormatValidator.toDefaultFormat(compoundToken);
				startDateTime.add(new Parameter(ParameterType.START_DATE, startDate));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String startTime = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				startDateTime.add(new Parameter(ParameterType.START_TIME, startTime));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String startTime = timeFormatValidator.toDefaultFormat(compoundToken);
				startDateTime.add(new Parameter(ParameterType.START_TIME, startTime));
				compoundToken = "";
			}
		}

		return startDateTime;
	}

	static ArrayList<Parameter> getEndDateTime(String parameterString, FormatValidator dateFormatValidator, 
													   FormatValidator timeFormatValidator) {
		ArrayList<Parameter> endDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(" ");
		String compoundToken = "";

		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + " " + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String endDate = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				endDateTime.add(new Parameter(ParameterType.END_DATE, endDate));
				compoundToken = "";
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String endDate = dateFormatValidator.toDefaultFormat(compoundToken);
				endDateTime.add(new Parameter(ParameterType.END_DATE, endDate));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String endTime = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				endDateTime.add(new Parameter(ParameterType.END_TIME, endTime));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String endTime = timeFormatValidator.toDefaultFormat(compoundToken);
				endDateTime.add(new Parameter(ParameterType.END_TIME, endTime));
				compoundToken = "";
			}
		}

		return endDateTime;
	}

	static ArrayList<Parameter> getDueDateTime(String parameterString, FormatValidator dateFormatValidator, 
													   FormatValidator timeFormatValidator) {
		ArrayList<Parameter> dueDateTime = new ArrayList<Parameter>();
		String parameterTokens[] = parameterString.split(" ");
		String compoundToken = "";

		for (int i = parameterTokens.length - 1; i >= 0; i--) {
			compoundToken = (parameterTokens[i] + " " + compoundToken).trim();
			if (dateFormatValidator.isValidFormat(parameterTokens[i])) {
				String date = dateFormatValidator.toDefaultFormat(parameterTokens[i]);
				dueDateTime.add(new Parameter(ParameterType.DATE, date));
				compoundToken = "";
			} else if (dateFormatValidator.isValidFormat(compoundToken)) {
				String date = dateFormatValidator.toDefaultFormat(compoundToken);
				dueDateTime.add(new Parameter(ParameterType.DATE, date));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(parameterTokens[i])) {
				String time = timeFormatValidator.toDefaultFormat(parameterTokens[i]);
				dueDateTime.add(new Parameter(ParameterType.TIME, time));
				compoundToken = "";
			} else if (timeFormatValidator.isValidFormat(compoundToken)) {
				String time = timeFormatValidator.toDefaultFormat(compoundToken);
				dueDateTime.add(new Parameter(ParameterType.TIME, time));
				compoundToken = "";
			}
		}
		
		return dueDateTime;
	}

	static Parameter getCategory(String parameterString) {
		String trimmedParameterString = parameterString.trim();
		return new Parameter(ParameterType.CATEGORY, trimmedParameterString);
	}

	static Parameter getPriority(String parameterString, FormatValidator priorityFormatValidator) throws IllegalArgumentException {
		String trimmedParameterString = parameterString.trim();
		if (trimmedParameterString.split(" ").length == 1) {
			if (priorityFormatValidator.isValidFormat(trimmedParameterString)) {
				String priority = priorityFormatValidator.toDefaultFormat(trimmedParameterString);
				return new Parameter(ParameterType.PRIORITY, priority);
			} else {
				throw new IllegalArgumentException("Invalid priority format provided.");
			}
		} else {
			throw new IllegalArgumentException("Invalid priority format provided.");
		}
	}
	
}

```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\ReminderParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.util.Parameter;

public class ReminderParameterParser implements ParameterParser {

	private Logger _logger;
	
	public ReminderParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of REMINDER command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		NumberFormatValidator indexFormatValidator = new NumberFormatValidator();
		parameters.add(ParameterParser.getIndex(parameterString, indexFormatValidator));
		
		_logger.log(Level.INFO, "Finished parsing parameters of REMINDER command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\RestoreParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.NumberFormatValidator;
import com.taskboard.main.util.Parameter;

public class RestoreParameterParser implements ParameterParser {

	private Logger _logger;
	
	public RestoreParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of RESTORE command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			throw new IllegalArgumentException("No parameters provided.");
		}
		
		FormatValidator indexFormatValidator =  new NumberFormatValidator();
		parameters.add(ParameterParser.getIndex(parameterString, indexFormatValidator));
		
		_logger.log(Level.INFO, "Finished parsing parameters of RESTORE command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\parser\ViewParameterParser.java
``` java
package com.taskboard.main.parser;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.taskboard.main.GlobalLogger;
import com.taskboard.main.formatvalidator.DateFormatValidator;
import com.taskboard.main.formatvalidator.FormatValidator;
import com.taskboard.main.formatvalidator.PriorityFormatValidator;
import com.taskboard.main.formatvalidator.TimeFormatValidator;
import com.taskboard.main.util.DelimiterType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class ViewParameterParser implements ParameterParser {
	
	private Logger _logger;
	
	public ViewParameterParser() {
		_logger = GlobalLogger.getInstance().getLogger();
	}
	
	public ArrayList<Parameter> parseParameters(String commandString) throws IllegalArgumentException {
		_logger.log(Level.INFO, "Started parsing parameters of VIEW command");
		
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		// remove the commandType token (add, edit, delete, etc.) and remove trailing whitespace
		String parameterString = new String();
		if (commandString.trim().indexOf(" ") != -1) {
			parameterString = commandString.substring(commandString.indexOf(" ")).trim();
		} else {
			// view command allows a command with no trailing parameter (return an empty ArrayList)
			return parameters;
		}
		
		ArrayList<DelimiterType> delimiterTypes = extractDelimiterTypes(parameterString);
		if (delimiterTypes.isEmpty()) {
			parameters.add(new Parameter(ParameterType.NAME, parameterString));
		} else {
			int expectedDelimiterId = 0;
			DelimiterType expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
			String expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
			
			String temporaryString = new String();
			String[] tokens = parameterString.split(" ");
			for (int i = tokens.length - 1; i >= 0; i--) {
				if (tokens[i].toLowerCase().equals(expectedDelimiterName)) {
					if (temporaryString.isEmpty()) {
						throw new IllegalArgumentException("Empty " + expectedDelimiterName + " parameter provided.");
					} else {
						temporaryString = reverseTokens(temporaryString);
						ArrayList<Parameter> parametersToAdd = convertToParameters(temporaryString, expectedDelimiterType);
						temporaryString = reverseTokens(temporaryString);
						if (parametersToAdd.isEmpty()) {
							temporaryString += ' ' + tokens[i];
						} else {
							parameters.addAll(parametersToAdd);
							temporaryString = "";
						}
					}
					
					expectedDelimiterId++;
					if (expectedDelimiterId < delimiterTypes.size()) {
						expectedDelimiterType = delimiterTypes.get(expectedDelimiterId);
						expectedDelimiterName = expectedDelimiterType.name().toLowerCase();
					} else {
						expectedDelimiterType = null;
						expectedDelimiterName = new String(); // name does not have delimiter
					}
				} else {
					temporaryString += ' ' + tokens[i];
				}
			}
			if (!temporaryString.isEmpty()) {
				temporaryString = reverseTokens(temporaryString);
				parameters.add(new Parameter(ParameterType.NAME, temporaryString));
			}
		}
		
		_logger.log(Level.INFO, "Finished parsing parameters of VIEW command");
		_logger.log(Level.INFO, "  Recognized parameters:");
		for (int i = 0; i < parameters.size(); i++) {
			_logger.log(Level.INFO, "    " + parameters.get(i).getParameterType().name() + ": " + 
						parameters.get(i).getParameterValue());
		}
		
		return parameters;
	}
	
	private static ArrayList<DelimiterType> extractDelimiterTypes(String parameterString) {
		ArrayList<DelimiterType> delimiterTypes = new ArrayList<DelimiterType>();
		
		parameterString = parameterString.toLowerCase();
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			if (tokens[i].equals("from") && !delimiterTypes.contains(DelimiterType.FROM)) {
				delimiterTypes.add(DelimiterType.FROM);
			} else if (tokens[i].equals("to") && !delimiterTypes.contains(DelimiterType.TO)) {
				delimiterTypes.add(DelimiterType.TO);
			} else if (tokens[i].equals("by") && !delimiterTypes.contains(DelimiterType.BY)) {
				delimiterTypes.add(DelimiterType.BY);
			} else if (tokens[i].equals("at") && !delimiterTypes.contains(DelimiterType.AT)) {
				delimiterTypes.add(DelimiterType.AT);
			} else if (tokens[i].equals("on") && !delimiterTypes.contains(DelimiterType.ON)) {
				delimiterTypes.add(DelimiterType.ON);
			} else if (tokens[i].equals("every") && !delimiterTypes.contains(DelimiterType.EVERY)) {
				delimiterTypes.add(DelimiterType.EVERY);
			} else if (tokens[i].equals("cat") && !delimiterTypes.contains(DelimiterType.CAT)) {
				delimiterTypes.add(DelimiterType.CAT);
			} else if (tokens[i].equals("pri") && !delimiterTypes.contains(DelimiterType.PRI)) {
				delimiterTypes.add(DelimiterType.PRI);
			}
		}
		
		return delimiterTypes;
	}
	
	private static String reverseTokens(String parameterString) {
		String resultString = new String();
		
		String[] tokens = parameterString.split(" ");
		for (int i = tokens.length - 1; i >= 0; i--) {
			resultString += tokens[i] + ' ';
		}
		
		return resultString.trim();
	}
	
	private static ArrayList<Parameter> convertToParameters(String parameterString, DelimiterType delimiterType) {
		ArrayList<Parameter> parameters = new ArrayList<Parameter>();
		FormatValidator dateFormatValidator = new DateFormatValidator();
		FormatValidator timeFormatValidator = new TimeFormatValidator();
		FormatValidator priorityFormatValidator = new PriorityFormatValidator();
		
		switch (delimiterType) {
			case FROM:
				parameters.addAll(ParameterParser.getStartDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case TO:
				parameters.addAll(ParameterParser.getEndDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case BY:
			case AT:
			case ON:
				parameters.addAll(ParameterParser.getDueDateTime(parameterString, dateFormatValidator, timeFormatValidator));
				break;
			case EVERY:
				// TBD: recurring task
				break;
			case CAT:
				parameters.add(ParameterParser.getCategory(parameterString));
				break;
			case PRI:
				parameters.add(ParameterParser.getPriority(parameterString, priorityFormatValidator));
				break;
			default:
				break;
		}
		
		return parameters;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\userinterface\BlinkingLabel.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.*;

import javax.swing.*;
import javax.swing.Timer;

public class BlinkingLabel extends JLabel {
	
	private static final long serialVersionUID = 5;
	private static final int DEFAULT_BLINK_RATE = 500;

	private int _blinkRate;
	private boolean _isBlinking;

	public BlinkingLabel() {
		super();
		_blinkRate = DEFAULT_BLINK_RATE;
		_isBlinking = true;
		Timer timer = new Timer(_blinkRate, new TimerListener(this));
		timer.setInitialDelay(0);
		timer.start();
	}

	public void setBlinking(boolean flag) {
		_isBlinking = flag;
	}
	public boolean isBlinking() {
		return _isBlinking;
	}

	private class TimerListener implements ActionListener {
		private BlinkingLabel bl;
		private boolean isVisible = true;

		public TimerListener(BlinkingLabel bl) {
			this.bl = bl;
		}

		public void actionPerformed(ActionEvent e) {
			if (bl.isBlinking()) {
				if (isVisible) {
					bl.setVisible(true);
				}
				else {
					bl.setVisible(false);
				}
				isVisible = !isVisible;
			}
			else {
				// Make sure that the label is visible if the blinking is off.
				if (isVisible) {
					bl.setVisible(true);
					isVisible = false;
				}
			}
		}

	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\userinterface\ShortcutListener.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.util.ArrayList;

public class ShortcutListener implements KeyListener {
	private static final String EXIT_COMMAND_STRING = "exit";
	private static final String HELP_COMMAND_STRING = "help";
	private static final String UNDO_COMMAND_STRING = "undo";
	
	final ArrayList<Integer> pressed = new ArrayList<Integer>();
	
	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub  
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		if (arg0.getKeyCode() == KeyEvent.VK_CONTROL) {
			pressed.remove(new Integer(KeyEvent.VK_CONTROL));
		}
	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		if (arg0.getKeyCode() == KeyEvent.VK_ENTER) {
			if (!UserInterface.getInstance().getCommandField().getText().isEmpty()) {
				UserInterface.getInstance().executeInputCommand();
			}
		} else if (arg0.getKeyCode() == KeyEvent.VK_CONTROL) {
			pressed.add(new Integer(KeyEvent.VK_CONTROL));
		} else if (pressed.contains(new Integer(KeyEvent.VK_CONTROL))) {
			if (arg0.getKeyCode() == KeyEvent.VK_Z) {
				UserInterface.getInstance().getCommandField().setText(UNDO_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
			} else if (arg0.getKeyCode() == KeyEvent.VK_Q) {
				UserInterface.getInstance().getCommandField().setText(EXIT_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
			} else if (arg0.getKeyCode() == KeyEvent.VK_H) {
				UserInterface.getInstance().getCommandField().setText(HELP_COMMAND_STRING);
				UserInterface.getInstance().executeInputCommand();
			}
		}
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\userinterface\WindowResizeListener.java
``` java
package com.taskboard.main.userinterface;

import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.io.IOException;

import javax.swing.JTextPane;

public class WindowResizeListener extends ComponentAdapter {
	// whenever the window is resized
	@Override
	public void componentResized(ComponentEvent frameResized) {
		try {
			UserInterface.getInstance().updateBackground();
		} catch (IOException e) {
			JTextPane feedbackArea = UserInterface.getInstance().getFeedbackArea();
			if (feedbackArea == null) {
				UserInterface.getInstance().setFeedbackArea(new JTextPane());
			}
			feedbackArea.setText("Unexpected error during background resize.");
		}
	}
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\CommandType.java
``` java
package com.taskboard.main.util;

public enum CommandType {
	ADD, EDIT, DELETE, VIEW, OPEN, NEW, COMPLETE, RESTORE, ARCHIVE, 
	UNDO, BACKGROUND, REMINDER, HELP, EXIT, UNKNOWN;
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\DelimiterType.java
``` java
package com.taskboard.main.util;

public enum DelimiterType {
	FROM, TO, BY, AT, ON, EVERY, CAT, PRI, NONE;
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\Entry.java
``` java
package com.taskboard.main.util;

import java.util.ArrayList;

public class Entry {
	
	// attribute
	
	private ArrayList<Parameter> _parameters;
	
	// constructor
	
	public Entry() {
		_parameters = new ArrayList<Parameter>();
	}
	
	public Entry(Entry oldEntry) {
		_parameters = new ArrayList<Parameter>();
		for (Parameter currentParameter: oldEntry.getParameters()) {
			_parameters.add(new Parameter(currentParameter));
		}
	}
	
	public Entry(ArrayList<Parameter> parameters) {
		_parameters = parameters;
	}
	
	// accessors
	
	public ArrayList<Parameter> getParameters() {
		return _parameters;
	}
	
	public Parameter getIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getNameParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getStartTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndDateParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getEndTimeParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getPriorityParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	public Parameter getCategoryParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				return _parameters.get(i);
			}
		}
		
		return null;
	}
	
	// mutators
	
	public void setParameters(ArrayList<Parameter> newParameters) {
		_parameters = newParameters;
	}
	
	public void addToParameters(Parameter newParameter) {
		_parameters.add(newParameter);
	}
	
	public void setIndexParameter(Parameter newIndexParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.set(i, newIndexParameter);
			}
		}
	}
	
	public void setNameParameter(Parameter newNameParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.NAME) {
				_parameters.set(i, newNameParameter);
			}
		}
	}

	public void setDateParameter(Parameter newDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.DATE) {
				_parameters.set(i, newDateParameter);
			}
		}
	}
	
	public void setTimeParameter(Parameter newTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.TIME) {
				_parameters.set(i, newTimeParameter);
			}
		}
	}
	
	public void setStartDateParameter(Parameter newStartDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_DATE) {
				_parameters.set(i, newStartDateParameter);
			}
		}
	}
	
	public void setStartTimeParameter(Parameter newStartTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.START_TIME) {
				_parameters.set(i, newStartTimeParameter);
			}
		}
	}
	
	public void setEndDateParameter(Parameter newEndDateParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_DATE) {
				_parameters.set(i, newEndDateParameter);
			}
		}
	}
	
	public void setEndTimeParameter(Parameter newEndTimeParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.END_TIME) {
				_parameters.set(i, newEndTimeParameter);
			}
		}
	}
	
	public void setCategoryParameter(Parameter newCategoryParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.CATEGORY) {
				_parameters.set(i, newCategoryParameter);
			}
		}
	}
	
	public void setPriorityParameter(Parameter newPriorityParameter) {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.PRIORITY) {
				_parameters.set(i, newPriorityParameter);
			}
		}
	}
	
	public void removeIndexParameter() {
		for (int i = 0; i < _parameters.size(); i++) {
			if (_parameters.get(i).getParameterType() == ParameterType.INDEX) {
				_parameters.remove(i);
				break;
			}
		}
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Entry) {
			Entry entry = (Entry) obj;
			Entry currentEntry = new Entry(this);
			Entry comparedEntry = new Entry(entry);
			
			currentEntry.removeIndexParameter();
			comparedEntry.removeIndexParameter();
			if (currentEntry.toString().equals(comparedEntry.toString())) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	
	@Override
	public String toString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			entryDetails = entryDetails.concat(detailType).concat(": ").concat(detail).concat("\n");
		}
		
		return entryDetails;
	}
	
	public String toHTMLString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			entryDetails = entryDetails.concat("<b>" + detailType + "</b>").concat(": ").concat(detail).concat("<br>");
		}
		
		return entryDetails;
	}
	
	public String toUIString() {
		String entryDetails = "";
		
		for (int i = 0; i < _parameters.size(); i++) {
			Parameter detailParameter = _parameters.get(i);
			String detailType;
			if (detailParameter.getParameterType() != null) {
				detailType = detailParameter.getParameterType().name();
			} else {
				detailType = "";
			}
			String detail = detailParameter.getParameterValue();
			if (!detailType.equals("INDEX") && !detailType.equals("CATEGORY") && !detailType.equals("PRIORITY")) {
				switch (detailType) {
					case "NAME":
						entryDetails += detail + "\n";
						break;
					case "DATE":
						if (getTimeParameter() != null) {
							entryDetails += "On " + detail + " ";
						} else {
							entryDetails += "On " + detail + "\n";
						}
						break;
					case "TIME":
						entryDetails += detail + "\n";
						break;
					case "START_DATE":
						if (getStartTimeParameter() != null) {
							entryDetails += "From " + detail + " ";
						} else {
							entryDetails += "From " + detail + " To ";
						}
						break;
					case "START_TIME":
						entryDetails += detail + " To ";
						break;
					case "END_DATE":
						if (getEndTimeParameter() != null) {
							entryDetails += detail + " ";
						} else {
							entryDetails += detail + "\n";
						}
						break;
					case "END_TIME":
						entryDetails += detail + "\n";
						break;
					default:
						entryDetails += detail + "\n";
						break;
				}
			}
		}
		
		return entryDetails;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\Parameter.java
``` java
package com.taskboard.main.util;

public class Parameter {
	
	// attributes
	
	private ParameterType _parameterType;
	private String _parameterValue;
	
	// constructors
	
	public Parameter() {
		
	}
	
	public Parameter(ParameterType parameterType, String parameterValue) {
		_parameterType = parameterType;
		_parameterValue = parameterValue;
	}
	
	public Parameter(Parameter oldParameter) {
		_parameterType = oldParameter.getParameterType();
		_parameterValue = oldParameter.getParameterValue();
	}
	
	// accessors
	
	public ParameterType getParameterType() {
		return _parameterType;
	}
	
	public String getParameterValue() {
		return _parameterValue;
	}
	
	// mutators
	
	public void setParameterType(ParameterType newParameterType) {
		_parameterType = newParameterType;
	}
	
	public void setParameterValue(String newParameterValue) {
		_parameterValue = newParameterValue;
	}
	
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\main\util\ParameterType.java
``` java
package com.taskboard.main.util;

public enum ParameterType {
	INDEX, NAME, NEW_NAME, DATE, TIME, START_DATE, START_TIME, END_DATE, 
	END_TIME, PRIORITY, CATEGORY;
}
```
###### D:\Java Projects\TaskBoard\src\com\taskboard\test\CommandParserTest.java
``` java
package com.taskboard.test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Date;
import java.util.Collections;
import java.text.SimpleDateFormat;

import com.taskboard.main.comparator.ParameterComparator;
import com.taskboard.main.parser.AddParameterParser;
import com.taskboard.main.parser.CommandTypeParser;
import com.taskboard.main.parser.CompleteParameterParser;
import com.taskboard.main.parser.DeleteParameterParser;
import com.taskboard.main.parser.EditParameterParser;
import com.taskboard.main.parser.ViewParameterParser;
import com.taskboard.main.util.CommandType;
import com.taskboard.main.util.Parameter;
import com.taskboard.main.util.ParameterType;

public class CommandParserTest {
	
	@Test
	public void testCommandTypeParser() {
		assertCommandType(CommandType.ADD, "Add");
		// all capital case test
		assertCommandType(CommandType.EDIT, "EDIT");
		// mixed case test
		assertCommandType(CommandType.DELETE, "deLeTE");
		// lower case test
		assertCommandType(CommandType.VIEW, "view");
		// this is a boundary case for UNKNOWN command partition
		assertCommandType(CommandType.UNKNOWN, "Addt");
		// this is a boundary case for empty string
		assertCommandType(CommandType.UNKNOWN, "");
	}
	
	private void assertCommandType(CommandType expected, String command) {
		assertEquals(expected, new CommandTypeParser().parseCommandType(command)); 
	}
	
	@Test
	public void testParameterParser() {
		// floating task adding test, 'multiple tokens' partition
		ArrayList<Parameter> expected1 = new ArrayList<Parameter>();
		expected1.add(new Parameter(ParameterType.NAME, "Hello again World!"));
		
		assertAddParameters(expected1, "add Hello again World!");
		
		// adding of complex descriptive task, 'multiple constraints' partition
		ArrayList<Parameter> expected2 = new ArrayList<Parameter>();
		expected2.add(new Parameter(ParameterType.NAME, "Meet Chris"));
		SimpleDateFormat defaultDateFormat = new SimpleDateFormat("dd/MM/yyyy");
		Date today = new Date();
		Date tomorrow = new Date(today.getTime() + (1000 * 60 * 60 * 24));
		expected2.add(new Parameter(ParameterType.START_DATE, defaultDateFormat.format(tomorrow)));
		expected2.add(new Parameter(ParameterType.START_TIME, "19:00"));
		expected2.add(new Parameter(ParameterType.END_DATE, defaultDateFormat.format(tomorrow)));
		expected2.add(new Parameter(ParameterType.END_TIME, "21:00"));
		expected2.add(new Parameter(ParameterType.CATEGORY, "meeting"));
		expected2.add(new Parameter(ParameterType.PRIORITY, "high"));
		
		assertAddParameters(expected2, "add Meet Chris from tomorrow 7pm to tomorrow 9pm cat meeting pri high");
		
		// adding of task with name containing a delimiter, 'ambiguous delimiter' partition
		ArrayList<Parameter> expected3 = new ArrayList<Parameter>();
		expected3.add(new Parameter(ParameterType.NAME, "Go to School from Home"));
		expected3.add(new Parameter(ParameterType.CATEGORY, "daily"));
		expected3.add(new Parameter(ParameterType.PRIORITY, "high"));
		
		assertAddParameters(expected3, "add Go to School from Home pri hi cat daily");
		
		// editing of complex descriptive task, 'multiple constraints' partition
		ArrayList<Parameter> expected4 = new ArrayList<Parameter>();
		expected4.add(new Parameter(ParameterType.INDEX, "12"));
		expected4.add(new Parameter(ParameterType.NEW_NAME, "test at school"));
		expected4.add(new Parameter(ParameterType.DATE, "13/10/2020"));
		expected4.add(new Parameter(ParameterType.TIME, "14:00"));
		expected4.add(new Parameter(ParameterType.PRIORITY, "medium"));
		expected4.add(new Parameter(ParameterType.CATEGORY, "test"));
		
		assertEditParameters(expected4, "edit 12 test at school at 13/10/2020 14:00 pri med cat test");
		
		// deleting of complex descriptive tasks, 'multiple constraints' partition
		ArrayList<Parameter> expected5 = new ArrayList<Parameter>();
		expected5.add(new Parameter(ParameterType.CATEGORY, "other"));
		expected5.add(new Parameter(ParameterType.PRIORITY, "low"));
		expected5.add(new Parameter(ParameterType.START_DATE, "23/10/2015"));
		expected5.add(new Parameter(ParameterType.END_DATE, "28/10/2015"));
		
		assertDeleteParameters(expected5, "delete cat other pri low from 23/10/2015 to 28/10/2015");
		
		// deleting task by index
		ArrayList<Parameter> expected6 = new ArrayList<Parameter>();
		expected6.add(new Parameter(ParameterType.INDEX, "102"));
		
		assertDeleteParameters(expected6, "delete 102");
		
		// viewing of all tasks, 'no constraint' partition
		ArrayList<Parameter> expected7 = new ArrayList<Parameter>();
		
		assertViewParameters(expected7, "view");
		
		// selective viewing of complex descriptive tasks, 'multiple constraints' partition
		ArrayList<Parameter> expected8 = new ArrayList<Parameter>();
		expected8.add(new Parameter(ParameterType.DATE, "25/10/2015"));
		expected8.add(new Parameter(ParameterType.CATEGORY, "Homework"));
		expected8.add(new Parameter(ParameterType.PRIORITY, "low"));
		
		assertViewParameters(expected8, "view by 25/10/2015 cat Homework pri low");
		
		// checking/marking of a task
		ArrayList<Parameter> expected9 = new ArrayList<Parameter>();
		expected9.add(new Parameter(ParameterType.INDEX, "5"));
		
		assertCheckParameters(expected9, "check 5");
	}
	
	private void assertAddParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new AddParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertEditParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new EditParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertDeleteParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new DeleteParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertViewParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new ViewParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private void assertCheckParameters(ArrayList<Parameter> expected, String command) {
		Collections.sort(expected, new ParameterComparator());
		ArrayList<Parameter> actual = new CompleteParameterParser().parseParameters(command);
		Collections.sort(actual, new ParameterComparator());
		assertEquals(toString(expected), toString(actual));
	}
	
	private static String toString(ArrayList<Parameter> parameters) {
		String resultString = new String();
		
		for (int i = 0; i < parameters.size(); i++) {
			resultString += parameters.get(i).getParameterType().name();
			resultString += ' ';
			resultString += parameters.get(i).getParameterValue();
			resultString += '\n';
		}
		
		System.out.println(resultString);
		
		return resultString;
	}

}
```
